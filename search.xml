<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux查看端口占用情况</title>
      <link href="/2022/08/08/linux%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5/"/>
      <url>/2022/08/08/linux%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>常常我们在linux都会通过<code>ps -ef | grep 关键字</code>查询服务进程,但如果查询linux的某个端口号占用情况呢？以下就是介绍相关知识内容</p></blockquote><h1 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h1><p><code>netstat -tunlp </code>用于显示 <code>tcp</code>，<code>udp</code>的端口和进程等相关情况。</p><p>netstat 查看端口占用语法格式：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -tunlp | grep 端口号</span><br></pre></td></tr></table></figure><p>-t (tcp) 仅显示tcp相关选项<br>-u (udp)仅显示udp相关选项<br>-n 拒绝显示别名，能显示数字的全部转化为数字<br>-l 仅列出在Listen(监听)的服务状态<br>-p 显示建立相关链接的程序名</p><p>例如查看 8000 端口的情况，使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netstat -tunlp | grep 8000</span></span><br><span class="line">tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN      26993/nodejs   </span><br></pre></td></tr></table></figure><p>更多的常用的查询类型</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -ntlp   //查看当前所有tcp端口</span><br><span class="line">netstat -ntulp | grep 80   //查看所有80端口使用情况</span><br><span class="line">netstat -ntulp | grep 3306   //查看所有3306端口使用情况</span><br></pre></td></tr></table></figure><h1 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h1><p>时常我们将查询到的服务进程号，并且想将其关闭就会用到kill指令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill -9 进程号</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop3.x-MapReduce</title>
      <link href="/2022/07/20/Hadoop3-x-MapReduce/"/>
      <url>/2022/07/20/Hadoop3-x-MapReduce/</url>
      
        <content type="html"><![CDATA[<h1 id="MapReduce概设"><a href="#MapReduce概设" class="headerlink" title="MapReduce概设"></a>MapReduce概设</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><code>MapReduce</code> 是一个<strong>分布式运算程序</strong>的编程框架，是用户开发“基于 Hadoop 的数据分析应用”的核心框架。<br><code>MapReduce</code> 核心功能是将<strong>用户编写的业务逻辑代码</strong>和<strong>自带默认组件</strong>整合成一个完整的分布式运算程序，并发运行在一个 Hadoop 集群上。</p><h2 id="优势劣势"><a href="#优势劣势" class="headerlink" title="优势劣势"></a>优势劣势</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>易于编程。用户只需要关心业务逻辑代码。实现框架的接口。</li><li>良好的扩展性：可以动态增加服务器数量，解决计算资源不够的问题。</li><li>高容错性：任何一台机器挂掉，可以将人物转移到其他节点。</li><li>适合海量数据计算（TB/PB）几千台服务器共同计算<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></li><li>不擅长实时计算。【MySQL-毫秒级】</li><li>不擅长流式计算。流式计算的输入数据是动态的，而 MapReduce 的<strong>输入数据集是静态的</strong>，不能动态变化。这是因为 MapReduce 自身的设计特点决定了数据源必须是静态的。【Sparkstreaming、flink】</li><li>不擅长DAG有向无环图计算。由于<strong>每个 MapReduce 作业的输出结果都会写入到磁盘，会造成大量的磁盘 IO，导致性能非常的低下。</strong>【Spark】</li></ol><h2 id="WordCount案例"><a href="#WordCount案例" class="headerlink" title="WordCount案例"></a>WordCount案例</h2><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h1 id="核心框架远离"><a href="#核心框架远离" class="headerlink" title="核心框架远离"></a>核心框架远离</h1><h2 id="输入的数据InputFormat"><a href="#输入的数据InputFormat" class="headerlink" title="输入的数据InputFormat"></a>输入的数据InputFormat</h2><h2 id="Shuffle"><a href="#Shuffle" class="headerlink" title="Shuffle"></a>Shuffle</h2><h2 id="输出数据OutputFormat"><a href="#输出数据OutputFormat" class="headerlink" title="输出数据OutputFormat"></a>输出数据OutputFormat</h2><h2 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h2><h2 id="ETL"><a href="#ETL" class="headerlink" title="ETL"></a>ETL</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h1 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h1><h2 id="有哪些压缩算法"><a href="#有哪些压缩算法" class="headerlink" title="有哪些压缩算法"></a>有哪些压缩算法</h2><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h2 id="在生产环境怎么用"><a href="#在生产环境怎么用" class="headerlink" title="在生产环境怎么用"></a>在生产环境怎么用</h2><h1 id="常见的问题及解决方案"><a href="#常见的问题及解决方案" class="headerlink" title="常见的问题及解决方案"></a>常见的问题及解决方案</h1>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS系统禁止开机启动</title>
      <link href="/2022/07/17/macOS%E7%B3%BB%E7%BB%9F%E7%A6%81%E6%AD%A2%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/"/>
      <url>/2022/07/17/macOS%E7%B3%BB%E7%BB%9F%E7%A6%81%E6%AD%A2%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用macOS开机时候，常常会发现很多软件开机会自动启动。正常情况可以在<code>系统偏好设置-&gt;用户与群组-&gt;登陆项</code>中找到相应的设置，没找到的第三方软件，可以通过对应的软件设置中开/关自动启动，但又存在部分流氓软件无法在这两种方式设置。以下是记录如何设置关闭流氓软件自启动项。</p></blockquote><h1 id="macOS-系统的启动项"><a href="#macOS-系统的启动项" class="headerlink" title="macOS 系统的启动项"></a>macOS 系统的启动项</h1><p>首先我们需要了解到macOS 系统的启动项会以 <code>.plist</code> 的文件存放：</p><ul><li><code>/Library/LaunchDaemons</code>：系统启动时运行，用户不登录也会运行</li><li><code>/Library/LaunchAgents</code>：用户登录后运行</li><li><code>~/Library/LaunchAgents</code>：用户自定义的用户启动项</li><li><code>/System/Library/LaunchDaemons</code>：系统自带的启动项</li><li><code>/System/Library/LaunchAgents</code>：系统自带的启动项</li></ul><h1 id="plist的属性设置"><a href="#plist的属性设置" class="headerlink" title="plist的属性设置"></a>plist的属性设置</h1><p>plist文件中，有3个属性是控制开机自动启动</p><ul><li><code>KeepAlive</code>：决定程序是否需要一直运行，如果是 false 则需要时才启动。<strong>默认 false</strong></li><li><code>RunAtLoad</code>：开机时是否运行。<strong>默认 false</strong></li><li><code>SuccessfulExit</code>：此项为 true 时，程序正常退出时重启（即退出码为 0）；为 false 时，程序非正常退出时重启。此项设置时会隐含默认 RunAtLoad = true，因为程序需要至少运行一次才能获得退出状态。</li></ul><h1 id="设置规则表现"><a href="#设置规则表现" class="headerlink" title="设置规则表现"></a>设置规则表现</h1><h2 id="KeepAlive-false的情况"><a href="#KeepAlive-false的情况" class="headerlink" title="KeepAlive = false的情况"></a>KeepAlive = false的情况</h2><ul><li><code>RunAtLoad = false</code> ：程序只有在有需要的时候运行。</li><li><code>RunAtLoad = true</code> ：程序在启动时会运行一次，然后等待在有需要的时候运行。</li><li><code>SuccessfulExit =  true / false</code> ：不论 RunAtLoad 值是什么，都会在启动时运行一次。其后根据 SuccessfulExit 值来决定是否重启。</li></ul><h1 id="开机不自启"><a href="#开机不自启" class="headerlink" title="开机不自启"></a>开机不自启</h1><blockquote><p>本文主题来了，一般我们安装的第三方软件的自启配置文件存放在<code>/Library/LaunchDaemons</code>、<code>/Library/LaunchAgents</code>,所以我们优先检查这2项</p></blockquote><ol><li>找到对应的 <code>.plist</code> 文件</li><li>删除 <code>SuccessfulExit</code> 属性。</li><li>将 <code>RunAtLoad / KeepAlive</code> 均设为 <code>&lt;false/&gt;</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>M1版macos使用brew安装hadoop3</title>
      <link href="/2022/07/15/M1%E7%89%88macos%E4%BD%BF%E7%94%A8brew%E5%AE%89%E8%A3%85hadoop3/"/>
      <url>/2022/07/15/M1%E7%89%88macos%E4%BD%BF%E7%94%A8brew%E5%AE%89%E8%A3%85hadoop3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>此篇文章记录博主使用M1版macos设备利用brew安装hadoop3，在本地安装伪分布式hadoop进行快速学习</p></blockquote><h1 id="【前提】-Homebrew安装"><a href="#【前提】-Homebrew安装" class="headerlink" title="【前提】 Homebrew安装"></a>【前提】 Homebrew安装</h1><p>Homebrew是OSX中非常优秀的包管理工具，如果没安装，可以前往博主博客搜索<code>Homebrew教程</code></p><h1 id="配置-ssh-localhost（免密登陆）"><a href="#配置-ssh-localhost（免密登陆）" class="headerlink" title="配置 ssh localhost（免密登陆）"></a>配置 ssh localhost（免密登陆）</h1><ol><li><p>因为安装hadoop需要远程登入的功能，所以需要安装<code>ssh</code>工具，但Mac下自带<code>ssh</code>，所以不需要另外安装<code>ssh</code>。</p></li><li><p>Macos X 只需要在<code>系统偏好设置--&gt;共享--&gt;远程登录</code>勾选就可以使用ssh了。<br><img src="/img/homebrew/ssh%E8%AE%BE%E7%BD%AE.jpg"><br>PS:如果没有执行远程登录勾选操作，在运行<code>ssh localhost</code>会出现：mac ssh: connect to host localhost port 22: Connection refused。</p></li><li><p>ssh免密设置：终端输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -P &quot;&quot;</span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></li><li><p>确认能否不输入口令就用ssh登录localhost:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh localhost</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="JDK-安装"><a href="#JDK-安装" class="headerlink" title="JDK 安装"></a>JDK 安装</h1><ul><li>查看java版本<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>如果macos没有安装<code>Java</code>，可以登录官网下载并安装，也可以通过brew安装<code>Java8</code></li></ul><h1 id="brew安装hadoop"><a href="#brew安装hadoop" class="headerlink" title="brew安装hadoop"></a>brew安装hadoop</h1><h2 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install hadoop</span></span><br></pre></td></tr></table></figure><h2 id="查看安装目录"><a href="#查看安装目录" class="headerlink" title="查看安装目录"></a>查看安装目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew list hadoop</span></span><br></pre></td></tr></table></figure><h2 id="配置Hadoop相关文件（此处伪分布式，还有单机模式和完全分布式模式）"><a href="#配置Hadoop相关文件（此处伪分布式，还有单机模式和完全分布式模式）" class="headerlink" title="配置Hadoop相关文件（此处伪分布式，还有单机模式和完全分布式模式）"></a>配置Hadoop相关文件（此处伪分布式，还有单机模式和完全分布式模式）</h2><ol><li><p>修改<code>/opt/homebrew/Cellar/hadoop/3.3.3/libexec/etc/hadoop/hadoop-env.sh</code>【根据自己安装目录修改】,添加内容如下：<br>JAVA_HOME的目录根据实际情况修改</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home</span><br></pre></td></tr></table></figure></li><li><p>修改<code>/opt/homebrew/Cellar/hadoop/3.3.3/libexec/etc/hadoop/core-site.xml</code>,添加如下内容：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/homebrew/Cellar/hadoop/hdfs/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>A base for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.default.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PS:<code>fs.default.name</code>保存了<code>NameNode</code>的位置，<code>HDFS</code>和<code>MapReduce</code>组件都需要用到它，这就是它出现在<code>core-site.xml</code> 文件中而不是 <code>hdfs-site.xml</code>文件中的原因。在该处配置HDFS的地址和端口号。</p></li><li><p>修改<code>/opt/homebrew/Cellar/hadoop/3.3.3/libexec/etc/hadoop/mapred-site.xml</code>,添加如下内容：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 变量mapred.job.tracker 保存了JobTracker的位置，因为只有MapReduce组件需要知道这个位置，所以它出现在mapred-site.xml文件中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapred.job.tracker<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost:9010<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--执行框架设置为hadoop yarn--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--历史服务器配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost:10200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>历史服务器web界面<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改<code>/opt/homebrew/Cellar/hadoop/3.3.3/libexec/etc/hadoop/hdfs-site.xml</code>,添加如下内容：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- dfs.permissions 默认值 true；还有几种方法可以解决，此处省略 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.permissions<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>变量dfs.replication指定了每个HDFS默认备份方式通常为3, 由于我们只有一台主机和一个伪分布式模式的DataNode，将此值修改为1。</p></li></ol><h1 id="运行haoop"><a href="#运行haoop" class="headerlink" title="运行haoop"></a>运行haoop</h1><h2 id="跳转到hadoop目录-opt-homebrew-Cellar-hadoop-3-3-3【以实际目录为准】"><a href="#跳转到hadoop目录-opt-homebrew-Cellar-hadoop-3-3-3【以实际目录为准】" class="headerlink" title="跳转到hadoop目录/opt/homebrew/Cellar/hadoop/3.3.3【以实际目录为准】"></a>跳转到hadoop目录<code>/opt/homebrew/Cellar/hadoop/3.3.3</code>【以实际目录为准】</h2><h2 id="启动hadoop之前需要格式化hadoop系统HDFS文件系统【已经格式化过的，就无需操作此步】"><a href="#启动hadoop之前需要格式化hadoop系统HDFS文件系统【已经格式化过的，就无需操作此步】" class="headerlink" title="启动hadoop之前需要格式化hadoop系统HDFS文件系统【已经格式化过的，就无需操作此步】"></a>启动hadoop之前需要格式化hadoop系统HDFS文件系统【已经格式化过的，就无需操作此步】</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hadoop namenode -format</span></span><br></pre></td></tr></table></figure><h2 id="进入-opt-homebrew-Cellar-hadoop-3-3-3-sbin-执行"><a href="#进入-opt-homebrew-Cellar-hadoop-3-3-3-sbin-执行" class="headerlink" title="进入/opt/homebrew/Cellar/hadoop/3.3.3/sbin,执行"></a>进入<code>/opt/homebrew/Cellar/hadoop/3.3.3/sbin</code>,执行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./start-all.sh</span></span><br></pre></td></tr></table></figure><p>或则分开启动：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./start-dfs.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./start-yarn.sh</span></span><br></pre></td></tr></table></figure><h2 id="jps命令查看java进程"><a href="#jps命令查看java进程" class="headerlink" title="jps命令查看java进程"></a>jps命令查看java进程</h2><p><img src="/img/hadoop3.x/jps%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B.png"></p><h1 id="构建远程连接的环境"><a href="#构建远程连接的环境" class="headerlink" title="构建远程连接的环境"></a>构建远程连接的环境</h1><h2 id="解压好hadoop3-1-3文件夹，将lib的文件复制到maven项目中"><a href="#解压好hadoop3-1-3文件夹，将lib的文件复制到maven项目中" class="headerlink" title="解压好hadoop3.1.3文件夹，将lib的文件复制到maven项目中"></a>解压好hadoop3.1.3文件夹，将lib的文件复制到maven项目中</h2><p><img src="/img/hadoop3.x/hadoop%E4%BE%9D%E8%B5%96%E5%8C%85.png"></p><h2 id="导入依赖包"><a href="#导入依赖包" class="headerlink" title="导入依赖包"></a>导入依赖包</h2><p><img src="/img/hadoop3.x/hadoop%E4%BE%9D%E8%B5%96%E5%8C%85%E5%AF%BC%E5%85%A5%E3%80%901%E3%80%91.jpg"><br><img src="/img/hadoop3.x/hadoop%E4%BE%9D%E8%B5%96%E5%8C%85%E5%AF%BC%E5%85%A5%E3%80%902%E3%80%91.png"></p><ol><li>将lib下面的文件夹多次依次导入 import files in one by one</li><li>打开lib下面的common，导入common下的lib包<br><img src="/img/hadoop3.x/%E4%BE%9D%E8%B5%96%E5%8C%85%E5%AF%BC%E5%85%A5%E6%83%85%E5%86%B5.png"></li><li>将远程hadoop启动，然后调用函数查看是否能连接成功</li></ol>]]></content>
      
      
      <categories>
          
          <category> Homebrew </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Homebrew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>M1版Macos的brew安装python2</title>
      <link href="/2022/07/15/M1%E7%89%88Macos%E7%9A%84brew%E5%AE%89%E8%A3%85python2/"/>
      <url>/2022/07/15/M1%E7%89%88Macos%E7%9A%84brew%E5%AE%89%E8%A3%85python2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Homebrew在MacOS中充当绝佳的包管理工具。通过brew安装python3非常简单，只需要通过指令<code>brew install python@3</code>,将会自动添加<code>python3</code>和<code>pip3</code>命令。</p></blockquote><h1 id="关于python2的安装"><a href="#关于python2的安装" class="headerlink" title="关于python2的安装"></a>关于python2的安装</h1><blockquote><p>由于博主使用的M1版Macos,所以这里只提供了<code>brew</code>如何安装<code>python2</code></p></blockquote><h2 id="brew安装pyenv"><a href="#brew安装pyenv" class="headerlink" title="brew安装pyenv"></a>brew安装pyenv</h2><p>执行以下命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install pyenv</span><br><span class="line">pyenv install 2.7.18</span><br><span class="line">export PATH=&quot;$(pyenv root)/shims:$&#123;PATH&#125;&quot;</span><br><span class="line">pyenv global 2.7.18</span><br><span class="line">python --version</span><br></pre></td></tr></table></figure><p>一切顺利会显示<code>python2</code>的版本输出。</p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>需要将上述路径添加到环境变量里面，例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;PATH=$(pyenv root)/shims:$PATH&#x27; &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><p><strong>PS：此方法可以与<code>brew install python3</code>方式安装的<code>python3</code>共存。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Homebrew </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Homebrew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>M1版Macos安装Homebrew教程</title>
      <link href="/2022/07/14/M1%E7%89%88Macos%E5%AE%89%E8%A3%85Homebrew%E6%95%99%E7%A8%8B/"/>
      <url>/2022/07/14/M1%E7%89%88Macos%E5%AE%89%E8%A3%85Homebrew%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于自己新买的设备是M1版Macos，了解到Homebrew装系统的开发环境比较方便，且易于管理，此文章作为学习记录笔记</p></blockquote><h1 id="安装ARM版Homebrew"><a href="#安装ARM版Homebrew" class="headerlink" title="安装ARM版Homebrew"></a>安装ARM版Homebrew</h1><p>执行命令后，会在<code>/opt/homebrew</code>路径下创建<code>homebrew</code>目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://gitee.com/ineo6/homebrew-install/raw/master/install.sh)&quot;</span><br></pre></td></tr></table></figure><p>然后还需要设置环境变量，需要先执行命令<code>echo $SHELL</code>显示的结果，接下来需在相应的环境文件配置<br>以下会出现这2种情况，以<strong>自己的系统显示为主</strong>：</p><ul><li><code>/bin/bash</code> =&gt; <code>bash</code> =&gt; <code>.bash_profile</code></li><li><code>/bin/zsh</code> =&gt; <code>zsh</code> =&gt; <code>.zprofile</code></li></ul><p>从<code>macOS Catalina(10.15.x) </code>版开始，Mac使用<code>zsh</code>作为默认<code>Shell</code>，使用.<code>zprofile</code>，所以对应命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#x27; &gt;&gt; ~/.zprofile</span><br><span class="line">eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;</span><br></pre></td></tr></table></figure><p>如果是<code>macOS Mojave</code> 及更低版本，并且没有自己配置过<code>zsh</code>，使用<code>.bash_profile</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;</span><br></pre></td></tr></table></figure><h1 id="安装x86版Homebrew"><a href="#安装x86版Homebrew" class="headerlink" title="安装x86版Homebrew"></a>安装x86版Homebrew</h1><blockquote><p>因为目前很多软件包没有支持ARM架构，我们也可以考虑使用x86版的Homebrew。<br>在命令前面添加arch -x86_64，就可以按X86模式执行该命令，比如：</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arch -x86_64 /bin/bash -c &quot;$(curl -fsSL https://gitee.com/ineo6/homebrew-install/raw/master/install.sh)&quot;</span><br></pre></td></tr></table></figure><h1 id="多版本共存"><a href="#多版本共存" class="headerlink" title="多版本共存"></a>多版本共存</h1><p>如果你同时安装了ARM和X86两个版本，那你需要设置别名，把命令区分开。<br>同样是<code>.zprofile</code>或者<code>.bash_profile</code>里面添加：</p><figure class="highlight profile"><table><tr><td class="code"><pre><span class="line">alias abrew=<span class="string">&#x27;arch -arm64 /opt/homebrew/bin/brew&#x27;</span></span><br><span class="line">alias ibrew=<span class="string">&#x27;arch -x86_64 /usr/local/bin/brew&#x27;</span></span><br></pre></td></tr></table></figure><p>然后执行<code>source ~/.zprofile</code>或<code>source ~/.bash_profile</code>命令更新文件。</p><h1 id="设置镜像"><a href="#设置镜像" class="headerlink" title="设置镜像"></a>设置镜像</h1><p><strong>注意：本文中的安装脚本会设置中科大源镜像，如果你也想设置cask和bottles的镜像，请按下面注释部分选择执行代码。</strong><br>执行时根据实际情况修改<code>&quot;$(brew --repo)&quot;</code>代码中的<code>brew</code>。</p><p>意思是如果你只是使用一个版本<code>Homebrew</code>，直接执行命令即可，如果你想多个版本共存或者使用了别名，就把brew关键字替换为别名名称，如前面的<code>abrew</code>、<code>ibrew</code>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> brew</span></span><br><span class="line">git -C &quot;$(brew --repo)&quot; remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> core</span></span><br><span class="line">git -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cask</span></span><br><span class="line">git -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> bottles <span class="keyword">for</span> zsh 和下面2选1</span></span><br><span class="line">echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles/bottles&#x27; &gt;&gt; ~/.zprofile</span><br><span class="line">source ~/.zprofile</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> bottles <span class="keyword">for</span> bash 和上面2选1</span></span><br><span class="line">echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles/bottles&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><h1 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h1><p>上方指令可能会在设置cask源的时候报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error: Fetching /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask failed!</span><br><span class="line">fatal: Could not resolve HEAD to a revision</span><br><span class="line">Failed during: /usr/local/bin/brew update --force --quiet</span><br></pre></td></tr></table></figure><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><h3 id="卸载已安装的Homebrew"><a href="#卸载已安装的Homebrew" class="headerlink" title="卸载已安装的Homebrew"></a>卸载已安装的Homebrew</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</span><br></pre></td></tr></table></figure><h3 id="安装新的Homebrew"><a href="#安装新的Homebrew" class="headerlink" title="安装新的Homebrew"></a>安装新的Homebrew</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span><br></pre></td></tr></table></figure><h3 id="选择中科大下载源"><a href="#选择中科大下载源" class="headerlink" title="选择中科大下载源"></a>选择中科大下载源</h3><p><img src="/img/homebrew/brew%E6%BA%90.jpg"></p><h3 id="根据提示运行source命令"><a href="#根据提示运行source命令" class="headerlink" title="根据提示运行source命令"></a>根据提示运行source命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /User/xxx/.zprofile</span><br></pre></td></tr></table></figure><h3 id="查看brew版本"><a href="#查看brew版本" class="headerlink" title="查看brew版本"></a>查看brew版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zzf@ZZFdeMacBook-Pro Cellar % brew -v</span><br><span class="line">Homebrew 3.5.4</span><br><span class="line">Homebrew/homebrew-core (git revision 466cd2c02f6; last commit 2022-07-10)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Homebrew </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Homebrew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/10/hello-world/"/>
      <url>/2022/07/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop3.X【HDFS】</title>
      <link href="/2022/06/27/Hadoop3-X%E3%80%90HDFS%E3%80%91/"/>
      <url>/2022/06/27/Hadoop3-X%E3%80%90HDFS%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="HDFS的产生背景和定义"><a href="#HDFS的产生背景和定义" class="headerlink" title="HDFS的产生背景和定义"></a>HDFS的产生背景和定义</h2><h3 id="HDFS-产生背景"><a href="#HDFS-产生背景" class="headerlink" title="HDFS 产生背景"></a>HDFS 产生背景</h3><p>随着数据量越来越大，在一个操作系统存不下所有的数据，那么就分配到更多的操作系统管理的磁盘中，但是不方便管理和维护，迫切<strong>需要一种系统来管理多台机器上的文件</strong>，这就是分布式文件管理系统。<strong>HDFS 只是分布式文件管理系统中的一种。</strong></p><h3 id="HDFS-定义"><a href="#HDFS-定义" class="headerlink" title="HDFS 定义"></a>HDFS 定义</h3><p><strong>HDFS（Hadoop Distributed File System）</strong>，它是一个文件系统，用于存储文件，通过目录树来定位文件；<strong>其次，它是分布式的</strong>，由很多服务器联合起来实现其功能，集群中的服务器有各自的角色。<br><strong>HDFS 的使用场景：适合一次写入，多次读出的场景。</strong>一个文件经过创建、写入和关闭之后就不需要改变。</p><h2 id="HDFS优缺点"><a href="#HDFS优缺点" class="headerlink" title="HDFS优缺点"></a>HDFS优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><p>高容错性<br><img src="/img/Hive/hdfs%E4%BC%98%E7%82%B91.png"></p></li><li><p>适合处理大数据<br><img src="/img/Hive/hdfs%E4%BC%98%E7%82%B92.png"></p></li><li><p>可<strong>构建在廉价机器上</strong>，通过多副本机制，提高可靠性。</p></li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><p><strong>不适合低延时数据访问</strong>，比如毫秒级的存储数据，是做不到的。</p></li><li><p>无法高效的对大量小文件进行存储。<br>(1)存储大量小文件的话，它会占用NameNode大量的内存来存储文件目录和块信息。这样是不可取的，因为NameNode的内存总是有限的；<br>(2)小文件存储的寻址时间会超过读取时间，它违反了HDFS的设计目标。</p></li><li><p>不支持并发写入、文件随机修改。<br>(1)一个文件只能有一个写，不允许多个线程同时写；<br>(2)<strong>仅支持数据append（追加）</strong>，不支持文件的随机修改。</p></li></ol><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><img src="/img/Hive/hdfs%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84.png"></p><p>(1) <code>NameNode（nn）</code>：就是Master，它是一个主管、管理者。</p><ul><li>管理HDFS的名称空间；</li><li>配置副本策略；</li><li>管理数据块（Block）映射信息；</li><li>处理客户端读写请求。</li></ul><p>(2) <code>DataNode</code>：就是Slave。NameNode下达命令，DataNode执行实际的操作。</p><ul><li>存储实际的数据块；</li><li>执行数据块的读/写操作</li></ul><p>(3) <code>Client</code>：就是客户端。</p><ul><li>文件切分。文件上传HDFS的时候，Client将文件切分成一个一个的Block，然后进行上传；</li><li>与NameNode交互，获取文件的位置信息；</li><li>与DataNode交互，读取或者写入数据；</li><li>Client提供一些命令来管理HDFS，比如NameNode格式化；</li><li>Client可以通过一些命令来访问HDFS，比如对HDFS增删查改操作</li></ul><p>(4) <code>Secondary NameNode</code>：并非NameNode的热备。当NameNode挂掉的时候，它并不能马上替换NameNode并提供服务。</p><ul><li>辅助NameNode，分担其工作量，比如定期合并Fsimage和Edits，并推送给NameNode ；</li><li>在紧急情况下，可辅助恢复NameNode。</li></ul><h2 id="HDFS文件块大小"><a href="#HDFS文件块大小" class="headerlink" title="HDFS文件块大小"></a>HDFS文件块大小</h2><p>HDFS中的文件在物理上是分块存储（Block），块的大小可以通过配置参数( dfs.blocksize）来规定，<strong>默认大小在Hadoop2.x/3.x版本中是128M，1.x版本中是64M。</strong><br><img src="/img/Hive/hdfs%E6%96%87%E4%BB%B6%E5%9D%97%E5%A4%A7%E5%B0%8F.png"></p><blockquote><p>思考：为什么块的大小不能设置太小，也不能设置太大？</p></blockquote><p>（1）HDFS的块设置<strong>太小</strong>，<strong>会增加寻址时间</strong>，程序一直在找块的开始位置；<br>（2）如果块设置的<strong>太大</strong>，<strong>从磁盘传输数据的时间</strong>会明显<strong>大于定位这个块开始位置所需的时间</strong>。导致程序在处理这块数据时，会非常慢。</p><p>总结：<strong>HDFS块的大小设置主要取决于磁盘传输速率。</strong></p><h1 id="HDFS的Shell相关操作-开发重点"><a href="#HDFS的Shell相关操作-开发重点" class="headerlink" title="HDFS的Shell相关操作 (开发重点)"></a>HDFS的Shell相关操作 (开发重点)</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><code>hadoop fs </code>具体命令 OR <code>hdfs dfs</code> 具体命令<br>两个是完全相同的。</p><h2 id="命令大全"><a href="#命令大全" class="headerlink" title="命令大全"></a>命令大全</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop102 hadoop-3.1.3]$ bin/hadoop fs</span><br><span class="line">[-appendToFile &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">    [-cat [-ignoreCrc] &lt;src&gt; ...]</span><br><span class="line">    [-chgrp [-R] GROUP PATH...]</span><br><span class="line">    [-chmod [-R] &lt;MODE[,MODE]... | OCTALMODE&gt; PATH...]</span><br><span class="line">    [-chown [-R] [OWNER][:[GROUP]] PATH...]</span><br><span class="line">    [-copyFromLocal [-f] [-p] &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">    [-copyToLocal [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;]</span><br><span class="line">    [-count [-q] &lt;path&gt; ...]</span><br><span class="line">    [-cp [-f] [-p] &lt;src&gt; ... &lt;dst&gt;]</span><br><span class="line">    [-df [-h] [&lt;path&gt; ...]]</span><br><span class="line">    [-du [-s] [-h] &lt;path&gt; ...]</span><br><span class="line">    [-get [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;]</span><br><span class="line">    [-getmerge [-nl] &lt;src&gt; &lt;localdst&gt;]</span><br><span class="line">    [-help [cmd ...]]</span><br><span class="line">    [-ls [-d] [-h] [-R] [&lt;path&gt; ...]]</span><br><span class="line">    [-mkdir [-p] &lt;path&gt; ...]</span><br><span class="line">    [-moveFromLocal &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">    [-moveToLocal &lt;src&gt; &lt;localdst&gt;]</span><br><span class="line">    [-mv &lt;src&gt; ... &lt;dst&gt;]</span><br><span class="line">    [-put [-f] [-p] &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">    [-rm [-f] [-r|-R] [-skipTrash] &lt;src&gt; ...]</span><br><span class="line">    [-rmdir [--ignore-fail-on-non-empty] &lt;dir&gt; ...]</span><br><span class="line">&lt;acl_spec&gt; &lt;path&gt;]]</span><br><span class="line">    [-setrep [-R] [-w] &lt;rep&gt; &lt;path&gt; ...]</span><br><span class="line">    [-stat [format] &lt;path&gt; ...]</span><br><span class="line">    [-tail [-f] &lt;file&gt;]</span><br><span class="line">    [-test -[defsz] &lt;path&gt;]</span><br><span class="line">    [-text [-ignoreCrc] &lt;src&gt; ...]</span><br></pre></td></tr></table></figure><h2 id="常用的命令实操"><a href="#常用的命令实操" class="headerlink" title="常用的命令实操"></a>常用的命令实操</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>启动Hadoop集群<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ sbin/start-dfs.sh</span><br><span class="line">[hdfs@hadoop103 hadoop-3.1.3]$ sbin/start-yarn.sh</span><br></pre></td></tr></table></figure></li><li>-help：输出这个命令参数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -help rm</span><br></pre></td></tr></table></figure></li><li>创建/sanguo 文件夹<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -mkdir /sanguo</span><br></pre></td></tr></table></figure></li></ol><h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><ol><li><p><code>-moveFromLocal</code>：从本地<strong>剪切</strong>粘贴到 HDFS</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ vim shuguo.txt</span><br><span class="line">输入：</span><br><span class="line">shuguo</span><br><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -moveFromLocal ./shuguo.txt /sanguo</span><br></pre></td></tr></table></figure></li><li><p><code>-copyFromLocal</code>：从本地文件系统中<strong>拷贝</strong>文件到 HDFS 路径去</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 hadoop-3.1.3]$ vim weiguo.txt</span><br><span class="line">输入：</span><br><span class="line">weiguo</span><br><span class="line">[atguigu@hadoop102 hadoop-3.1.3]$ hadoop fs -copyFromLocal weiguo.txt /sanguo</span><br></pre></td></tr></table></figure></li><li><p><code>-put</code>：等同于 copyFromLocal，生产环境更习惯用 put</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ vim wuguo.txt</span><br><span class="line">输入：</span><br><span class="line">wuguo</span><br><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -put ./wuguo.txt /sanguo</span><br></pre></td></tr></table></figure></li><li><p><code>-appendToFile</code>：追加一个文件到已经存在的文件末尾</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ vim liubei.txt</span><br><span class="line">输入：</span><br><span class="line">liubei</span><br><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -appendToFile liubei.txt /sanguo/shuguo.txt</span><br></pre></td></tr></table></figure></li></ol><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ol><li><p><code>-copyToLocal</code>：从 HDFS 拷贝到本地</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -copyToLocal /sanguo/shuguo.txt ./</span><br></pre></td></tr></table></figure></li><li><p><code>-get</code>：等同于 copyToLocal，生产环境更习惯用 get</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -get /sanguo/shuguo.txt ./shuguo2.txt</span><br></pre></td></tr></table></figure></li></ol><h3 id="HDFS-直接操作"><a href="#HDFS-直接操作" class="headerlink" title="HDFS 直接操作"></a>HDFS 直接操作</h3><ol><li><p><code>-ls</code>: 显示目录信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -ls /sanguo</span><br></pre></td></tr></table></figure></li><li><p><code>-cat</code>：显示文件内容</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -cat /sanguo/shuguo.txt</span><br></pre></td></tr></table></figure></li><li><p><code>-chgrp</code>、<code>-chmod</code>、<code>-chown：Linux</code> 文件系统中的用法一样，修改文件所属权限</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -chmod 666 /sanguo/shuguo.txt</span><br><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -chown hdfs:hdfs /sanguo/shuguo.txt</span><br></pre></td></tr></table></figure></li><li><p><code>-mkdir</code>：创建路径</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -mkdir /jinguo</span><br></pre></td></tr></table></figure></li><li><p><code>-cp</code>：从 HDFS 的一个路径拷贝到 HDFS 的另一个路径</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -cp /sanguo/shuguo.txt /jinguo</span><br></pre></td></tr></table></figure></li><li><p><code>-mv</code>：在 HDFS 目录中移动文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -mv /sanguo/wuguo.txt /jinguo</span><br><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -mv /sanguo/weiguo.txt /jinguo</span><br></pre></td></tr></table></figure></li><li><p><code>-tail</code>：显示一个文件的末尾 1kb 的数据</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -tail /jinguo/shuguo.txt</span><br></pre></td></tr></table></figure></li><li><p><code>-rm</code>：删除文件或文件夹</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -rm /sanguo/shuguo.txt</span><br></pre></td></tr></table></figure></li><li><p><code>-rm -r</code>：递归删除目录及目录里面内容</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -rm -r /sanguo</span><br></pre></td></tr></table></figure></li><li><p><code>-du</code> 统计文件夹的大小信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -du -s -h /jinguo</span><br><span class="line">27 81 /jinguo</span><br><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -du -h /jinguo</span><br><span class="line">14 42 /jinguo/shuguo.txt</span><br><span class="line">7 21 /jinguo/weiguo.txt</span><br><span class="line">6 18 /jinguo/wuguo.tx</span><br></pre></td></tr></table></figure></li><li><p><code>-setrep</code>：设置 HDFS 中文件的副本数量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hdfs@hadoop102 hadoop-3.1.3]$ hadoop fs -setrep 10 /jinguo/shuguo.txt</span><br></pre></td></tr></table></figure><blockquote><p>这里设置的副本数只是记录在 NameNode 的元数据中，是否真的会有这么多副本，还得看 DataNode 的数量。<strong>因为目前只有 3 台设备，最多也就 3个副本，只有节点数的增加到 10台时，副本数才能达到 10。</strong></p></blockquote></li></ol><h1 id="HDFS的客户端API操作"><a href="#HDFS的客户端API操作" class="headerlink" title="HDFS的客户端API操作"></a>HDFS的客户端API操作</h1><h2 id="window下的环境准备"><a href="#window下的环境准备" class="headerlink" title="window下的环境准备"></a>window下的环境准备</h2><ol><li><p>找到资料包路径下的 <code>Windows </code>依赖文件夹，拷贝 hadoop-3.1.0 到非中文路径（比如 d:\）【建议】。</p></li><li><p>配置<code>HADOOP_HOME</code>环境变量<br><img src="/img/hadoop3.x/window%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E3%80%901%E3%80%91.png"></p></li><li><p>配置 <code>Path </code>环境变量。<br>注意：如果环境变量不起作用，可以重启电脑试试。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%HADOOP_HOME%\bin</span><br></pre></td></tr></table></figure><p><img src="/img/hadoop3.x/window%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E3%80%902%E3%80%91.png"></p></li><li><p>在 IDEA 中创建一个 Maven 工程 HdfsClientDemo，并导入相应的依赖坐标+日志添加</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在项目的 <code>src/main/resources</code> 目录下，新建一个文件，命名为<code>&quot;log4j.properties&quot;</code>，在文件中填入</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">INFO, stdout </span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender </span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout </span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%d %p [%c] - %m%n </span></span><br><span class="line"><span class="meta">log4j.appender.logfile</span>=<span class="string">org.apache.log4j.FileAppender </span></span><br><span class="line"><span class="meta">log4j.appender.logfile.File</span>=<span class="string">target/spring.log </span></span><br><span class="line"><span class="meta">log4j.appender.logfile.layout</span>=<span class="string">org.apache.log4j.PatternLayout </span></span><br><span class="line"><span class="meta">log4j.appender.logfile.layout.ConversionPattern</span>=<span class="string">%d %p [%c] - %m%n</span></span><br></pre></td></tr></table></figure></li><li><p>创建包名：com.atguigu.hdfs</p></li><li><p>创建 HdfsClient 类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atgui.hdfs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HdfsClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMkdirs</span><span class="params">()</span> <span class="keyword">throws</span> IOException, URISyntaxException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取文件系统</span></span><br><span class="line"></span><br><span class="line">    Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">    <span class="comment">// FileSystem fs = FileSystem.get(newURI(&quot;hdfs://hadoop102:8020&quot;), configuration);</span></span><br><span class="line">    FileSystem fs = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">&quot;hdfs://hadoop102:8020&quot;</span>), configuration,<span class="string">&quot;zzf&quot;</span>);</span><br><span class="line">    <span class="comment">// 2 创建目录</span></span><br><span class="line">     fs.mkdirs(<span class="keyword">new</span> Path(<span class="string">&quot;/xiyou/huaguoshan/&quot;</span>));</span><br><span class="line">    <span class="comment">// 3 关闭资源</span></span><br><span class="line">     fs.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>客户端去操作 HDFS 时，是有一个用户身份的。默认情况下，HDFS 客户端 API 会从采用 Windows 默认用户访问 HDFS，会报权限异常错误。所以在访问 HDFS 时，一定要配置用户。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.apache.hadoop.security.AccessControlException: Permission denied: user=56576, access=WRITE, inode=&quot;/xiyou/huaguoshan&quot;:atguigu:supergroup:drwxr-xr-x</span><br></pre></td></tr></table></figure></li></ol><h2 id="HDFS的API案例实操"><a href="#HDFS的API案例实操" class="headerlink" title="HDFS的API案例实操"></a>HDFS的API案例实操</h2><h3 id="HDFS文件上传（测试参数优先级）"><a href="#HDFS文件上传（测试参数优先级）" class="headerlink" title="HDFS文件上传（测试参数优先级）"></a>HDFS文件上传（测试参数优先级）</h3><ol><li><p>编写源代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HDFS文件上传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> URISyntaxException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCopyFromLocalFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException, URISyntaxException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取文件系统</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        configuration.set(<span class="string">&quot;dfs.replication&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">        FileSystem fs = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">&quot;hdfs://hadoop102:8020&quot;</span>), configuration, <span class="string">&quot;zzf&quot;</span>);</span><br><span class="line">        <span class="comment">// 2 上传文件</span></span><br><span class="line">        fs.copyFromLocalFile(<span class="keyword">new</span> Path(<span class="string">&quot;C:\\Users\\BHY\\Desktop\\sunwukong.txt&quot;</span>), <span class="keyword">new</span> Path(<span class="string">&quot;/xiyou/huaguoshan&quot;</span>));</span><br><span class="line">        <span class="comment">// 3 关闭资源</span></span><br><span class="line">        fs.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>将 <code>hdfs-site.xml </code>拷贝到项目的<code> resources</code> 资源目录下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>参数优先级<br>参数优先级排序：（1）客户端代码中设置的值 &gt;（2）ClassPath 下的用户自定义配置文件 &gt;（3）然后是服务器的自定义配置（xxx-site.xml）&gt;（4）服务器的默认配置（xxx-default.xml）</p></li></ol><h3 id="HDFS-文件下载"><a href="#HDFS-文件下载" class="headerlink" title="HDFS 文件下载"></a>HDFS 文件下载</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下载文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> URISyntaxException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCopyToLocalFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">            InterruptedException, URISyntaxException</span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取文件系统</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        FileSystem fs = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">&quot;hdfs://hadoop102:8020&quot;</span>),</span><br><span class="line">                configuration, <span class="string">&quot;zzf&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 执行下载操作</span></span><br><span class="line">        <span class="comment">// boolean delSrc 指是否将原文件删除</span></span><br><span class="line">        <span class="comment">// Path src 指要下载的文件路径</span></span><br><span class="line">        <span class="comment">// Path dst 指将文件下载到的路径</span></span><br><span class="line">        <span class="comment">// boolean useRawLocalFileSystem 是否开启文件校验</span></span><br><span class="line">        fs.copyToLocalFile(<span class="keyword">false</span>,</span><br><span class="line">                    <span class="keyword">new</span> Path(<span class="string">&quot;/xiyou/huaguoshan/sunwukong.txt&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> Path(<span class="string">&quot;C:\\Users\\BHY\\Desktop\\sunwukong2.txt&quot;</span>),</span><br><span class="line">                    <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 关闭资源</span></span><br><span class="line">        fs.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果执行上面代码，下载不了文件，有可能是你电脑的微软支持的运行库少，需要安装一下微软运行库。</p></blockquote><h3 id="HDFS-文件更名和移动"><a href="#HDFS-文件更名和移动" class="headerlink" title="HDFS 文件更名和移动"></a>HDFS 文件更名和移动</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 更名或移动文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> URISyntaxException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRename</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException,</span></span><br><span class="line"><span class="function">           URISyntaxException</span>&#123;</span><br><span class="line">       <span class="comment">// 1 获取文件系统</span></span><br><span class="line">       Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">       FileSystem fs = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">&quot;hdfs://hadoop102:8020&quot;</span>),</span><br><span class="line">               configuration, <span class="string">&quot;zzf&quot;</span>);</span><br><span class="line">       <span class="comment">// 2 修改文件名称</span></span><br><span class="line">       fs.rename(<span class="keyword">new</span> Path(<span class="string">&quot;/xiyou/huaguoshan/sunwukong.txt&quot;</span>), <span class="keyword">new</span></span><br><span class="line">               Path(<span class="string">&quot;/xiyou/huaguoshan/meihouwang.txt&quot;</span>));</span><br><span class="line">       <span class="comment">// 3 关闭资源</span></span><br><span class="line">       fs.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="HDFS-删除文件和目录"><a href="#HDFS-删除文件和目录" class="headerlink" title="HDFS 删除文件和目录"></a>HDFS 删除文件和目录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> URISyntaxException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException,</span></span><br><span class="line"><span class="function">            URISyntaxException</span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取文件系统</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        FileSystem fs = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">&quot;hdfs://hadoop102:8020&quot;</span>),</span><br><span class="line">                configuration, <span class="string">&quot;zzf&quot;</span>);</span><br><span class="line">        <span class="comment">// 2 执行删除</span></span><br><span class="line">        fs.delete(<span class="keyword">new</span> Path(<span class="string">&quot;/xiyou&quot;</span>), <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 3 关闭资源</span></span><br><span class="line">        fs.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="HDFS-文件详情查看"><a href="#HDFS-文件详情查看" class="headerlink" title="HDFS 文件详情查看"></a>HDFS 文件详情查看</h3><p>查看文件名称、权限、长度、块信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* HDFS 文件详情查看</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> URISyntaxException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListFiles</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException,</span></span><br><span class="line"><span class="function">            URISyntaxException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取文件系统</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        FileSystem fs = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">&quot;hdfs://hadoop102:8020&quot;</span>),</span><br><span class="line">                configuration, <span class="string">&quot;zzf&quot;</span>);</span><br><span class="line">        <span class="comment">// 2 获取文件详情</span></span><br><span class="line">        RemoteIterator&lt;LocatedFileStatus&gt; listFiles = fs.listFiles(<span class="keyword">new</span> Path(<span class="string">&quot;/&quot;</span>), <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">while</span> (listFiles.hasNext()) &#123;</span><br><span class="line">            LocatedFileStatus fileStatus = listFiles.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;========&quot;</span> + fileStatus.getPath() + <span class="string">&quot;=========&quot;</span>);</span><br><span class="line">            System.out.println(fileStatus.getPermission());</span><br><span class="line">            System.out.println(fileStatus.getOwner());</span><br><span class="line">            System.out.println(fileStatus.getGroup());</span><br><span class="line">            System.out.println(fileStatus.getLen());</span><br><span class="line">            System.out.println(fileStatus.getModificationTime());</span><br><span class="line">            System.out.println(fileStatus.getReplication());</span><br><span class="line">            System.out.println(fileStatus.getBlockSize());</span><br><span class="line">            System.out.println(fileStatus.getPath().getName());</span><br><span class="line">            <span class="comment">// 获取块信息</span></span><br><span class="line">            BlockLocation[] blockLocations = fileStatus.getBlockLocations();</span><br><span class="line">            System.out.println(Arrays.toString(blockLocations));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3 关闭资源</span></span><br><span class="line">        fs.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="HDFS-文件和文件夹判断"><a href="#HDFS-文件和文件夹判断" class="headerlink" title="HDFS 文件和文件夹判断"></a>HDFS 文件和文件夹判断</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HDFS 文件和文件夹判断</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> URISyntaxException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListStatus</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException,</span></span><br><span class="line"><span class="function">            URISyntaxException</span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取文件配置信息</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        FileSystem fs = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">&quot;hdfs://hadoop102:8020&quot;</span>),</span><br><span class="line">                configuration, <span class="string">&quot;zzf&quot;</span>);</span><br><span class="line">        <span class="comment">// 2 判断是文件还是文件夹</span></span><br><span class="line">        FileStatus[] listStatus = fs.listStatus(<span class="keyword">new</span> Path(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (FileStatus fileStatus : listStatus) &#123;</span><br><span class="line">            <span class="comment">// 如果是文件</span></span><br><span class="line">            <span class="keyword">if</span> (fileStatus.isFile()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;f:&quot;</span>+fileStatus.getPath().getName());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;d:&quot;</span>+fileStatus.getPath().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3 关闭资源</span></span><br><span class="line">        fs.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="HDFS的读写流程-面试重点"><a href="#HDFS的读写流程-面试重点" class="headerlink" title="HDFS的读写流程(面试重点)"></a>HDFS的读写流程(面试重点)</h1><h2 id="HDFS写数据流程"><a href="#HDFS写数据流程" class="headerlink" title="HDFS写数据流程"></a>HDFS写数据流程</h2><h3 id="剖析文件写入"><a href="#剖析文件写入" class="headerlink" title="剖析文件写入"></a>剖析文件写入</h3><p><img src="/img/hadoop3.x/hdfs%E5%86%99%E6%B5%81%E7%A8%8B.png"></p><ol><li>客户端通过 <code>Distributed FileSystem</code> 模块向 <code>NameNode</code> 请求上传文件，<code>NameNode</code> 检查目标文件是否已存在，父目录是否存在。</li><li><code>NameNode</code> 返回是否可以上传。</li><li>客户端请求第一个 <code>Block</code> 上传到哪几个 <code>DataNode</code> 服务器上。</li><li><code>NameNode</code> 返回 3 个 <code>DataNode</code> 节点，分别为 <code>dn1</code>、<code>dn2</code>、<code>dn3</code>。</li><li>客户端通过 <code>FSDataOutputStream</code> 模块请求 <code>dn1</code> 上传数据，<code>dn1</code> 收到请求会继续调用<code>dn2</code>，然后 <code>dn2</code> 调用 <code>dn3</code>，将这个通信管道建立完成。</li><li><code>dn1</code>、<code>dn2</code>、<code>dn3</code> 逐级应答客户端。</li><li>客户端开始往 <code>dn1</code> 上传第一个 <code>Block</code>（先从磁盘读取数据放到一个本地内存缓存），以 <code>Packet</code> 为单位，<code>dn1</code> 收到一个 <code>Packet</code> 就会传给 <code>dn2</code>，<code>dn2</code> 传给 <code>dn3</code>；<code>dn1</code> 每传一个<code>packet</code>会放入一个应答队列等待应答。</li><li>当一个 <code>Block</code> 传输完成之后，客户端再次请求 <code>NameNode </code>上传第二个 <code>Block</code> 的服务器。（重复执行 3-7 步）。</li></ol><h3 id="网络拓扑-节点距离计算"><a href="#网络拓扑-节点距离计算" class="headerlink" title="网络拓扑-节点距离计算"></a>网络拓扑-节点距离计算</h3><blockquote><p>在 HDFS 写数据的过程中，NameNode 会选择距离待上传数据最近距离的 DataNode 接收数据。那么这个最近距离怎么计算呢<br><strong>节点距离：两个节点到达最近的共同祖先的距离总和。</strong><br><img src="/img/hadoop3.x/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91-%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%E8%AE%A1%E7%AE%97.png"></p></blockquote><h3 id="HDFS读数据流程"><a href="#HDFS读数据流程" class="headerlink" title="HDFS读数据流程"></a>HDFS读数据流程</h3><p><img src="/img/hadoop3.x/HDFS%E7%9A%84%E8%AF%BB%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B.png"></p><ol><li>客户端通过 <code>DistributedFileSystem</code> 向 <code>NameNode</code> 请求下载文件，<code>NameNode</code> 通过查询元数据，找到文件块所在的 <code>DataNode</code> 地址。</li><li>挑选一台 <code>DataNode</code>（就近原则，然后随机）服务器，请求读取数据。</li><li><code>DataNode</code> 开始传输数据给客户端（从磁盘里面读取数据输入流，以 <code>Packet</code> 为单位来做校验）。</li><li>客户端以 <code>Packet</code> 为单位接收，先在本地缓存，然后写入目标文件。</li></ol><h1 id="NameNode-和-SecondaryNameNode"><a href="#NameNode-和-SecondaryNameNode" class="headerlink" title="NameNode 和 SecondaryNameNode"></a>NameNode 和 SecondaryNameNode</h1><h2 id="NN-和-2NN-工作机制"><a href="#NN-和-2NN-工作机制" class="headerlink" title="NN 和 2NN 工作机制"></a>NN 和 2NN 工作机制</h2><blockquote><p>思考：<code>NameNode</code> 中的元数据是存储在哪里的？</p></blockquote><p>首先，我们做个假设，如果存储在 <code>NameNode</code> 节点的磁盘中，因为经常需要进行随机访问，还有响应客户请求，必然是效率过低。因此，元数据需要存放在内存中。但如果只存在内存中，一旦断电，元数据丢失，整个集群就无法工作了。<strong>因此产生在磁盘中备份元数据的<code>FsImage</code>。</strong></p><p>这样又会带来新的问题，当在内存中的元数据更新时，如果同时更新 <code>FsImage</code>，就会导致效率过低，但如果不更新，就会发生一致性问题，一旦 <code>NameNode</code> 节点断电，就会产生数据丢失。<strong>因此，引入 <code>Edits</code> 文件（只进行追加操作，效率很高）。每当元数据有更新或者添加元据时，修改内存中的元数据并追加到 <code>Edits</code> 中。</strong>这样，一旦 <code>NameNode</code> 节点断电，可以通过 <code>FsImage</code> 和 <code>Edits</code> 的合并，合成元数据。</p><p>但是，如果长时间添加数据到 <code>Edits</code> 中，会导致该文件数据过大，效率降低，而且一旦断电，恢复元数据需要的时间过长。因此，需要定期进行 <code>FsImage</code> 和 <code>Edits</code> 的合并，如果这个操作由<code>NameNode</code>节点完成，又会效率过低。<strong>因此，引入一个新的节点<code>SecondaryNamenode</code>，专门用于 <code>FsImage</code> 和 <code>Edits</code> 的合并。</strong><br><img src="/img/hadoop3.x/NameNode%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6.png"></p><ol><li><p>第一阶段：<code>NameNode</code> 启动<br>（1）第一次启动 <code>NameNode</code> 格式化后，创建 <code>Fsimage</code> 和 <code>Edits</code> 文件。如果不是第一次启动，直接加载编辑日志和镜像文件到内存。<br>（2）客户端对元数据进行增删改的请求。<br>（3）<code>NameNode</code> 记录操作日志，更新滚动日志。<br>（4）<code>NameNode</code> 在内存中对元数据进行增删改。</p></li><li><p>第二阶段：<code>Secondary NameNode</code> 工作<br>（1）<code>Secondary NameNode</code> 询问 <code>NameNode</code> 是否需要 <code>CheckPoint</code>。直接带回 <code>NameNode</code>是否检查结果。<br>（2）<code>Secondary NameNode</code> 请求执行 <code>CheckPoint</code>。<br>（3）<code>NameNode</code> 滚动正在写的 <code>Edits</code> 日志。<br>（4）将滚动前的编辑日志和镜像文件拷贝到 <code>Secondary NameNode</code>。<br>（5）<code>Secondary NameNode</code> 加载编辑日志和镜像文件到内存，并合并。<br>（6）生成新的镜像文件 <code>fsimage.chkpoint</code>。<br>（7）拷贝 <code>fsimage.chkpoint</code> 到<code> NameNode</code>。<br>（8）<code>NameNode</code> 将 <code>fsimage.chkpoint</code> 重新命名成 <code>fsimage</code>。</p></li></ol><h2 id="CheckPoint-时间设置"><a href="#CheckPoint-时间设置" class="headerlink" title="CheckPoint 时间设置"></a>CheckPoint 时间设置</h2><h1 id="Datanode工作机制"><a href="#Datanode工作机制" class="headerlink" title="Datanode工作机制"></a>Datanode工作机制</h1>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据-Hive3.x</title>
      <link href="/2022/06/07/%E5%A4%A7%E6%95%B0%E6%8D%AE-Hive3/"/>
      <url>/2022/06/07/%E5%A4%A7%E6%95%B0%E6%8D%AE-Hive3/</url>
      
        <content type="html"><![CDATA[<h1 id="第-1-章-Hive-基本概念"><a href="#第-1-章-Hive-基本概念" class="headerlink" title="第 1 章 Hive 基本概念"></a>第 1 章 Hive 基本概念</h1><h2 id="什么是-Hive"><a href="#什么是-Hive" class="headerlink" title="什么是 Hive"></a>什么是 Hive</h2><ol><li> hive 简介<br>Hive：由 Facebook 开源用于解决海量<code>结构化</code>日志的数据统计工具。<br>Hive 是基于 Hadoop 的一个<code>数据仓库工具</code>，可以将<code>结构化的数据文件映射为一张表</code>，提供<code>类 SQL</code> 查询功能.</li><li>Hive 本质<br>将 HQL 转化成 <code>MapReduce</code> 程序<br><img src="/img/Hive/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211109105855.png"></li></ol><ul><li>Hive 处理的数据存储在 <code>HDFS</code></li><li>Hive 分析数据底层的实现是 <code>MapReduce</code></li><li>执行程序运行在 <code>Yarn</code> 上</li></ul><h2 id="Hive-的优缺点"><a href="#Hive-的优缺点" class="headerlink" title="Hive 的优缺点"></a>Hive 的优缺点</h2><ol><li>优点</li></ol><ul><li>操作接口采用类 SQL 语法，提供快速开发的能力（简单、容易上手）。</li><li>避免了去写 MapReduce，减少开发人员的学习成本。</li><li>Hive 的执行延迟比较高，因此 Hive 常用于数据分析，对实时性要求不高的场合。</li><li>Hive 优势在于处理大数据，对于处理小数据没有优势，因为 Hive 的执行延迟比较高。</li><li>Hive 支持用户自定义函数，用户可以根据自己的需求来实现自己的函数。</li></ul><ol start="2"><li>缺点</li></ol><ul><li>Hive 的 HQL 表达能力有限<br>（1）迭代式算法无法表达<br>（2）数据挖掘方面不擅长，由于 MapReduce 数据处理流程的限制，效率更高的算法却无法实现。</li><li>Hive 的效率比较低<br>（1）Hive 自动生成的 MapReduce 作业，通常情况下不够智能化<br>（2）Hive 调优比较困难，粒度较粗</li></ul><h2 id="Hive-架构原理"><a href="#Hive-架构原理" class="headerlink" title="Hive 架构原理"></a>Hive 架构原理</h2><p><img src="/img/Hive/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211109154724.png"></p><ol><li>用户接口：Client<br>CLI（command-line interface）、JDBC/ODBC(jdbc 访问 hive)、WEBUI（浏览器访问 hive）</li><li>元数据：Metastore<br>元数据包括：表名、表所属的数据库（默认是 default）、表的拥有者、列/分区字段、表的类型（是否是外部表）、表的数据所在目录等；<br><code>默认存储在自带的 derby 数据库中，推荐使用 MySQL 存储 Metastore</code></li><li>Hadoop<br>使用 HDFS 进行存储，使用 MapReduce 进行计算。</li><li>驱动器：Driver</li></ol><ul><li>解析器（SQL Parser）：将 SQL 字符串转换成抽象语法树 AST，这一步一般都用第<br>三方工具库完成，比如 antlr；对 AST 进行语法分析，比如表是否存在、字段是否存在、SQL<br>语义是否有误。</li><li>编译器（Physical Plan）：将 AST 编译生成逻辑执行计划。</li><li>优化器（Query Optimizer）：对逻辑执行计划进行优化。</li><li>执行器（Execution）：把逻辑执行计划转换成可以运行的物理计划。对于 Hive 来说，就是 MR/Spark。<br><img src="/img/Hive/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211109155818.png"><br>Hive 通过给用户提供的一系列交互接口，接收到用户的指令(SQL)，使用自己的 Driver，结合元数据(MetaStore)，将这些指令翻译成 MapReduce，提交到 Hadoop 中执行，最后，将执行返回的结果输出到用户交互接口。</li></ul><h2 id="Hive-和数据库比较"><a href="#Hive-和数据库比较" class="headerlink" title="Hive 和数据库比较"></a>Hive 和数据库比较</h2><p>由于 Hive 采用了类似 SQL 的查询语言 HQL(Hive Query Language)，因此很容易将 Hive 理解为数据库。其实从结构上来看，Hive 和数据库除了拥有类似的查询语言，再无类似之处。<br>本文将从多个方面来阐述 Hive 和数据库的差异。数据库可以用在 Online 的应用中，但是Hive 是为数据仓库而设计的，清楚这一点，有助于从应用角度理解 Hive 的特性。</p><h3 id="查询语言"><a href="#查询语言" class="headerlink" title="查询语言"></a>查询语言</h3><p>由于 SQL 被广泛的应用在数据仓库中，因此，专门针对 Hive 的特性设计了类 SQL 的查询语言 HQL。熟悉 SQL 开发的开发者可以很方便的使用 Hive 进行开发。</p><h3 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h3><p>由于 Hive 是针对数据仓库应用设计的，而<code>数据仓库的内容是读多写少的</code>。因此，<code>Hive 中不建议对数据的改写，所有的数据都是在加载的时候确定好的</code>。而数据库中的数据通常是需要经常进行修改的，因此可以使用 INSERT INTO … VALUES 添加数据，使用 UPDATE … SET 修改数据。</p><h3 id="执行延迟"><a href="#执行延迟" class="headerlink" title="执行延迟"></a>执行延迟</h3><p>Hive 在查询数据的时候，由于没有索引，需要扫描整个表，因此延迟较高。另外一个导致 Hive 执行延迟高的因素是 MapReduce 框架。由于 MapReduce 本身具有较高的延迟，因此在利用 MapReduce 执行 Hive 查询时，也会有较高的延迟。相对的，数据库的执行延迟较低。当然，这个低是有条件的，即数据规模较小，当数据规模大到超过数据库的处理能力的时候，Hive 的并行计算显然能体现出优势。</p><h3 id="数据规模"><a href="#数据规模" class="headerlink" title="数据规模"></a>数据规模</h3><p>由于 Hive 建立在集群上并可以利用 MapReduce 进行并行计算，因此可以支持很大规模的数据；对应的，数据库可以支持的数据规模较小。</p><h1 id="Hive安装"><a href="#Hive安装" class="headerlink" title="Hive安装"></a>Hive安装</h1><h2 id="Hive安装地址"><a href="#Hive安装地址" class="headerlink" title="Hive安装地址"></a>Hive安装地址</h2><ol><li>Hive官网地址<br><a href="http://hive.apache.org/">http://hive.apache.org</a></li><li>文档查看地址<br><a href="https://cwiki.apache.org/confluence/display/Hive/GettingStarted">https://cwiki.apache.org/confluence/display/Hive/GettingStarted</a></li><li>下载地址<br><a href="http://archive.apache.org/dist/hive/">http://archive.apache.org /dist/hive/</a></li><li>github地址<br><a href="https://github.com/apache/hive">https://github.com/apache/hive</a></li></ol><h2 id="Hive安装部署"><a href="#Hive安装部署" class="headerlink" title="Hive安装部署"></a>Hive安装部署</h2><h3 id="安装Hive"><a href="#安装Hive" class="headerlink" title="安装Hive"></a>安装Hive</h3><blockquote><p>此hive版本由自己学习决定，路径目录同理</p></blockquote><ol><li>把 <code>apache-hive-3.1.2-bin.tar.gz</code> 上传到 linux 的<code>/opt/software</code>目录下</li><li>解压 <code>apache-hive-3.1.2-bin.tar.gz</code> 到<code>/opt/module/</code>目录下面<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf /opt/software/apache-hive-3.1.2-bin.tar.gz -C /opt/module/</span><br></pre></td></tr></table></figure></li><li>修改<code>apache-hive-3.1.2-bin</code>的名称为<code>hive</code><blockquote><p>此处可自由决定是否修改</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv /opt/module/apache-hive-3.1.2-bin/ /opt/module/hive</span><br></pre></td></tr></table></figure></li><li>修改<code>/etc/profile.d/my_env.sh</code>，添加环境变量<blockquote><p>此处可以自己在<code>/etc/profile.d/</code>目录下创建自己的环境变量,也可以直接配置在<code>/etc/profile</code>中</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/profile.d/my_env.sh</span><br></pre></td></tr></table></figure></li><li>添加文件内容<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">HIVE_HOME</span></span><br><span class="line">export HIVE_HOME=/opt/module/hive</span><br><span class="line">export PATH=$PATH:$HIVE_HOME/bin</span><br></pre></td></tr></table></figure></li><li>解决日志Jar冲突<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv $HIVE_HOME/lib/log4j-slf4j-impl-2.10.0.jar $HIVE_HOME/lib/log4j-slf4j-impl-2.10.0.bak</span><br></pre></td></tr></table></figure></li><li>初始化元数据<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">HIVE_HOME/bin/schematool -dbType derby -initSchema</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="启动并使用Hive"><a href="#启动并使用Hive" class="headerlink" title="启动并使用Hive"></a>启动并使用Hive</h3><ol><li>启动Hive<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/hive</span><br></pre></td></tr></table></figure></li><li>使用Hive<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> show databases;</span> </span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> show tables;</span></span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> create table <span class="built_in">test</span>(id int);</span> </span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> insert into <span class="built_in">test</span> values(1);</span> </span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> select * from <span class="built_in">test</span>;</span></span><br></pre></td></tr></table></figure><blockquote><p>Hive默认使用的元数据库为<code>derby</code>,开启Hive之后就用占用源数据库,且不与其他客户端共享数据，所以我们需要将Hive的元数据地址改为<code>Mysql</code>【单窗口运行可以，多窗口时则只有一个窗口能正常运行，其他窗口报错】</p></blockquote></li></ol><h2 id="MySQL安装【如果自己已安装过MYSQL，可跳过】"><a href="#MySQL安装【如果自己已安装过MYSQL，可跳过】" class="headerlink" title="MySQL安装【如果自己已安装过MYSQL，可跳过】"></a>MySQL安装【如果自己已安装过MYSQL，可跳过】</h2><ol><li><p>检查当前系统是否安装过MySQL</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep mariadb</span><br></pre></td></tr></table></figure><blockquote><p>如果系统安装了Mysql，则会出现相应的mysql版本，例如<code>mariadb-libs-5.5.56-2.el7.x86_64</code></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">删除mysql命令</span></span><br><span class="line">sudo rpm -e --nodeps  mariadb-libs</span><br></pre></td></tr></table></figure></li><li><p>将 <code>MySQL</code> 安装包拷贝到<code>/opt/software</code> 目录下</p></li><li><p>解压<code>MySQL</code>安装包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">解压mysql安装包</span></span><br><span class="line">tar -xf mysql-5.7.28-1.el7.x86_64.rpm-bundle.tar</span><br></pre></td></tr></table></figure><p><img src="/img/Hive/mysql%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6%E5%90%8E%E5%9B%BE%E7%89%87.png"></p></li><li><p>在安装目录下执行 rpm 安装</p><blockquote><p>注意：按照顺序依次执行</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rpm -ivh mysql-community-common-5.7.28-1.el7.x86_64.rpm </span><br><span class="line">sudo rpm -ivh mysql-community-libs-5.7.28-1.el7.x86_64.rpm</span><br><span class="line">sudo rpm -ivh mysql-community-libs-compat-5.7.28-1.el7.x86_64.rpm </span><br><span class="line">sudo rpm -ivh mysql-community-client-5.7.28-1.el7.x86_64.rpm</span><br><span class="line">sudo rpm -ivh mysql-community-server-5.7.28-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></li><li><p>删除<code>/etc/my.cnf </code>文件中 datadir 指向的目录下的所有内容,如果有内容的情况下:<br>查看<code>datadir</code>的值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld] datadir=/var/lib/mysql</span><br></pre></td></tr></table></figure><blockquote><p>删除<code>/var/lib/mysql</code> 目录下的所有内容:</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注意执行命令的位置</span></span><br><span class="line">sudo rm -rf /var/lib/mysql/*</span><br></pre></td></tr></table></figure></li><li><p>初始化数据库</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mysqld --initialize --user=mysql</span><br></pre></td></tr></table></figure></li><li><p>查看临时生成的<code>root</code>用户的密码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cat /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p><img src="/img/Hive/mysql%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%86%E7%A0%81.png"></p></li><li><p>启动Mysql服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start mysqld</span><br></pre></td></tr></table></figure></li><li><p>登录 MySQL 数据库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line">Enter password:输入临时生成的密码</span><br></pre></td></tr></table></figure></li><li><p>必须先修改root用户密码，否则执行其他的操作会报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql &gt; set password = password(&quot;新密码&quot;); </span><br></pre></td></tr></table></figure></li><li><p>修改 mysql 库下的 user 表中的 root 用户允许任意 ip 连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; update mysql.user set host=&#x27;%&#x27; where user=&#x27;root&#x27;; </span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Hive-元数据配置到-MySQL"><a href="#Hive-元数据配置到-MySQL" class="headerlink" title="Hive 元数据配置到 MySQL"></a>Hive 元数据配置到 MySQL</h2><h3 id="拷贝驱动"><a href="#拷贝驱动" class="headerlink" title="拷贝驱动"></a>拷贝驱动</h3><p>将 MySQL 的 JDBC 驱动拷贝到 Hive 的 lib 目录下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /opt/software/mysql-connector-java-5.1.37.jar $HIVE_HOME/lib</span><br></pre></td></tr></table></figure><h3 id="配置-Metastore-到-MySQL"><a href="#配置-Metastore-到-MySQL" class="headerlink" title="配置 Metastore 到 MySQL"></a>配置 Metastore 到 MySQL</h3><ol><li><p>在<code>$HIVE_HOME/conf</code> 目录下新建 <code>hive-site.xml</code> 文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim $HIVE_HOME/conf/hive-site.xml</span><br></pre></td></tr></table></figure><blockquote><p>添加如下内容</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jdbc 连接的 URL --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://hadoop102:3306/metastore?useSSL=false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- jdbc 连接的 Driver--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- jdbc 连接的 username--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- jdbc 连接的 password --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>000000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Hive 元数据存储版本的验证 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.schema.verification<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--元数据存储授权--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.event.db.notification.api.auth<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Hive 默认在 HDFS 的工作目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/user/hive/warehouse<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>登录MySQL</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p自定义密码</span><br></pre></td></tr></table></figure></li><li><p>新建Hive元数据</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create database metastore;</span> </span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> quit;</span></span><br></pre></td></tr></table></figure></li><li><p>初始化Hive元数据库</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">schematool -initSchema -dbType mysql - verbose</span><br></pre></td></tr></table></figure></li></ol><h3 id="再次启动Hive"><a href="#再次启动Hive" class="headerlink" title="再次启动Hive"></a>再次启动Hive</h3><ol><li>启动Hive<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/hive</span><br></pre></td></tr></table></figure></li><li>使用hive<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; show databases; </span><br><span class="line">hive&gt; show tables;</span><br><span class="line">hive&gt; create table test (id int); </span><br><span class="line">hive&gt; insert into test values(1); </span><br><span class="line">hive&gt; select * from test;</span><br></pre></td></tr></table></figure></li><li>启动另外一个窗口开启Hive<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> show databases;</span> </span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> show tables;</span> </span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> select * from aa;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="使用元数据服务的方式访问-Hive"><a href="#使用元数据服务的方式访问-Hive" class="headerlink" title="使用元数据服务的方式访问 Hive"></a>使用元数据服务的方式访问 Hive</h2><blockquote><p>由于上方的配置只能服务器访问，此处操作用作外部访问，例如代码访问hive数据源</p></blockquote><ol><li>在 <code>hive-site.xml</code> 文件中添加如下配置信息<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定存储元数据要连接的地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.uris<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>thrift://hadoop102:9083<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>启动metastore<blockquote><p>前台运行</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hive --service metastore </span><br><span class="line">2020-04-24 16:58:08: Starting Hive Metastore Server </span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意: 启动后窗口不能再操作，需打开一个新的 shell 窗口做别的操作</span></span><br></pre></td></tr></table></figure></li><li>启动hive<blockquote><p>运行服务器客户端查看</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/hive</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用JDBC方式访问Hive"><a href="#使用JDBC方式访问Hive" class="headerlink" title="使用JDBC方式访问Hive"></a>使用JDBC方式访问Hive</h2><ol><li>在 <code>hive-site.xml</code> 文件中添加如下配置信息<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定 hiveserver2 连接的 host --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.server2.thrift.bind.host<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定 hiveserver2 连接的端口号 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.server2.thrift.port<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>10000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>启动hiveserver2<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/hive --service hiveserver2</span><br></pre></td></tr></table></figure></li><li>启动beeline客户端(需要多等待一会)<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/beeline -u jdbc:hive2://hadoop102:10000 -n atguigu</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 参数</span><br><span class="line">The Beeline CLI 支持以下命令行参数:    </span><br><span class="line">Option    </span><br><span class="line">Description    </span><br><span class="line">--autoCommit=[true/false] ---进入一个自动提交模式：beeline --autoCommit=true    </span><br><span class="line">--autosave=[true/false]   ---进入一个自动保存模式：beeline --autosave=true    </span><br><span class="line">--color=[true/false]    ---显示用到的颜色：beeline --color=true    </span><br><span class="line">--delimiterForDSV= DELIMITER ---分隔值输出格式的分隔符。默认是“|”字符。    </span><br><span class="line">--fastConnect=[true/false]  ---在连接时，跳过组建表等对象：beeline --fastConnect=false    </span><br><span class="line">--force=[true/false]    ---是否强制运行脚本：beeline--force=true    </span><br><span class="line">--headerInterval=ROWS   ---输出的表间隔格式，默认是100: beeline --headerInterval=50    </span><br><span class="line">--help ---帮助  beeline --help    </span><br><span class="line">--hiveconf property=value  ---设置属性值，以防被hive.conf.restricted.list重置：beeline --hiveconf prop1=value1     </span><br><span class="line">--hivevar name=value   ---设置变量名：beeline --hivevar var1=value1    </span><br><span class="line">--incremental=[true/false]  ---输出增量  </span><br><span class="line">--isolation=LEVEL  ---设置事务隔离级别：beeline --isolation=TRANSACTION_SERIALIZABLE    </span><br><span class="line">--maxColumnWidth=MAXCOLWIDTH ---设置字符串列的最大宽度：beeline --maxColumnWidth=25    </span><br><span class="line">--maxWidth=MAXWIDTH ---设置截断数据的最大宽度：beeline --maxWidth=150    </span><br><span class="line">--nullemptystring=[true/false]  ---打印空字符串：beeline --nullemptystring=false    </span><br><span class="line">--numberFormat=[pattern]     ---数字使用DecimalFormat：beeline --numberFormat=&quot;#,###,##0.00&quot;    </span><br><span class="line">--outputformat=[table/vertical/csv/tsv/dsv/csv2/tsv2] ---输出格式：beeline --outputformat=tsv     </span><br><span class="line">--showHeader=[true/false]   ---显示查询结果的列名：beeline --showHeader=false    </span><br><span class="line">--showNestedErrs=[true/false] ---显示嵌套错误：beeline --showNestedErrs=true    </span><br><span class="line">--showWarnings=[true/false] ---显示警告：beeline --showWarnings=true    </span><br><span class="line">--silent=[true/false]  ---减少显示的信息量：beeline --silent=true    </span><br><span class="line">--truncateTable=[true/false] ---是否在客户端截断表的列       </span><br><span class="line">--verbose=[true/false]  ---显示详细错误信息和调试信息：beeline --verbose=true    </span><br><span class="line">-d &lt;driver class&gt;  ---使用一个驱动类：beeline -d driver_class    </span><br><span class="line">-e &lt;query&gt;  ---使用一个查询语句：beeline -e &quot;query_string&quot;    </span><br><span class="line">-f &lt;file&gt;  ---加载一个文件：beeline -f filepath  多个文件用-e file1 -e file2  </span><br><span class="line">-n &lt;username&gt;  ---加载一个用户名：beeline -n valid_user    </span><br><span class="line">-p &lt;password&gt;  ---加载一个密码：beeline -p valid_password    </span><br><span class="line">-u &lt;database URL&gt; ---加载一个JDBC连接字符串：beeline -u db_URL   &lt;/span&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>登录成功界面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connecting to jdbc:hive2://hadoop102:10000 </span><br><span class="line">Connected to: Apache Hive (version 3.1.2) </span><br><span class="line">Driver: Hive JDBC (version 3.1.2)</span><br><span class="line">Transaction isolation: TRANSACTION_REPEATABLE_READ </span><br><span class="line">Beeline version 3.1.2 by Apache Hive</span><br><span class="line">0: jdbc:hive2://hadoop102:10000&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写hive服务启动脚本(了解)</p><blockquote><p>前台启动的方式导致需要打开多个 shell 窗口，可以使用如下方式后台方式启动<br><code>nohup</code>:  放在命令开头，表示不挂起,也就是关闭终端进程也继续保持运行状态<br><code>/dev/null</code>：是 Linux 文件系统中的一个文件，被称为黑洞，所有写入改文件的内容 都会被自动丢弃<br><code>2&gt;&amp;1</code> :  表示将错误重定向到标准输出上<br><code>&amp;</code>:  放在命令结尾,表示后台运行<br>一般会组合使用: <code>nohup [xxx 命令操作]&gt; file 2&gt;&amp;1 &amp;</code>，表示将 xxx 命令运行的结 果输出到 file 中，并保持命令启动的进程在后台运行。</p></blockquote></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop202 hive]$ nohup hive --service metastore 2&gt;&amp;1 &amp; </span><br><span class="line">[root@hadoop202 hive]$ nohup hive --service hiveserver2 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>(1) 编写hiverserver脚本</p><blockquote><p>为了方便使用，可以直接编写脚本来管理服务的启动和关闭</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim $HIVE_HOME/bin/hiveservices.sh</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">!/bin/bash </span><br><span class="line">HIVE_LOG_DIR=<span class="variable">$HIVE_HOME</span>/logs</span><br><span class="line"><span class="comment"># -d 判断当前路径是否存在，并且是否是文件夹</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$HIVE_LOG_DIR</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        mkdir -p <span class="variable">$HIVE_LOG_DIR</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#检查进程是否运行正常，参数 1 为进程名，参数 2 为进程端口</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">check_process</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">#grep -v grep 表示查询内容不包含grep[-v 则表示不包含，-i就是包含(默认)]</span></span><br><span class="line">        <span class="comment">#awk 分割</span></span><br><span class="line">        <span class="comment">#&#123;print $2&#125; 取分割后的第二位结果</span></span><br><span class="line">        pid=$(ps -ef 2&gt;/dev/null | grep -v grep | grep -i <span class="variable">$1</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line">        <span class="comment">#netstat -nltp |grep 端口号 |awk &#x27;print&#123;print $7&#125;&#x27; 通过端口号查进程号</span></span><br><span class="line">        <span class="comment">#cut -d &#x27;/&#x27; -f 1 通过&#x27;/&#x27;分割 取第一位</span></span><br><span class="line">        ppid=$(netstat -nltp 2&gt;/dev/null | grep <span class="variable">$2</span> | awk <span class="string">&#x27;&#123;print $7&#125;&#x27;</span> | cut -d <span class="string">&#x27;/&#x27;</span> -f 1)</span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$pid</span></span><br><span class="line">        [[ <span class="string">&quot;<span class="variable">$pid</span>&quot;</span> =~ <span class="string">&quot;<span class="variable">$ppid</span>&quot;</span> ]] &amp;&amp; [ <span class="string">&quot;<span class="variable">$ppid</span>&quot;</span> ] &amp;&amp; <span class="built_in">return</span> 0 || <span class="built_in">return</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hive_start</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">        metapid=$(check_process HiveMetastore 9083)</span><br><span class="line">        cmd=<span class="string">&quot;nohup hive --service metastore &gt;<span class="variable">$HIVE_LOG_DIR</span>/metastore.log 2&gt;&amp;1&amp;&quot;</span></span><br><span class="line">        <span class="comment">#如果metapid返回值为0，就走cmd指令，反之返回值为1，控制台输出提示   -z判断字符串是否为0</span></span><br><span class="line">        <span class="comment">#eval等于语句解析完再执行，sh只解析一层</span></span><br><span class="line">        [ -z <span class="string">&quot;<span class="variable">$metapid</span>&quot;</span> ] &amp;&amp; <span class="built_in">eval</span> <span class="variable">$cmd</span> || <span class="built_in">echo</span> <span class="string">&quot;Metastroe 服务已启动&quot;</span> </span><br><span class="line">        server2pid=$(check_process HiveServer2 10000)</span><br><span class="line">        cmd=<span class="string">&quot;nohup hive --service hiveserver2 &gt;<span class="variable">$HIVE_LOG_DIR</span>/hiveServer2.log 2&gt;&amp;1 &amp;&quot;</span></span><br><span class="line">        [ -z <span class="string">&quot;<span class="variable">$server2pid</span>&quot;</span> ] &amp;&amp; <span class="built_in">eval</span> <span class="variable">$cmd</span> || <span class="built_in">echo</span> <span class="string">&quot;HiveServer2 服务已启动&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hive_stop</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">        metapid=$(check_process HiveMetastore 9083)</span><br><span class="line">        [ <span class="string">&quot;<span class="variable">$metapid</span>&quot;</span> ] &amp;&amp; <span class="built_in">kill</span> <span class="variable">$metapid</span> || <span class="built_in">echo</span> <span class="string">&quot;Metastore 服务未启动&quot;</span></span><br><span class="line">         server2pid=$(check_process HiveServer2 10000)</span><br><span class="line">        [ <span class="string">&quot;<span class="variable">$server2pid</span>&quot;</span> ] &amp;&amp; <span class="built_in">kill</span> <span class="variable">$server2pid</span> || <span class="built_in">echo</span> <span class="string">&quot;HiveServer2 服务未启动&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line"><span class="string">&quot;start&quot;</span>)</span><br><span class="line">        hive_start</span><br><span class="line">        ;;</span><br><span class="line"><span class="string">&quot;stop&quot;</span>)</span><br><span class="line">        hive_stop</span><br><span class="line">        ;;</span><br><span class="line"><span class="string">&quot;restart&quot;</span>)</span><br><span class="line">        hive_stop sleep 2 hive_start</span><br><span class="line">        ;;</span><br><span class="line"><span class="string">&quot;status&quot;</span>)</span><br><span class="line">        check_process HiveMetastore 9083 &gt;/dev/null &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Metastore 服务运行 正常&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;Metastore 服务运行 异常&quot;</span></span><br><span class="line">        check_process HiveServer2 10000 &gt;/dev/null &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;HiveServer2 服务运行 正常&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;HiveServer2 服务运行 异常&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">*)</span><br><span class="line">        <span class="built_in">echo</span> Invalid Args!</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&#x27;Usage: &#x27;</span>$(basename <span class="variable">$0</span>)<span class="string">&#x27; start|stop|restart|status&#x27;</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>(2) 添加执行权限</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop102 hive]$ chmod +x $HIVE_HOME/bin/hiveservices.sh</span><br></pre></td></tr></table></figure><p>(3) 启动Hive后台服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop102 hive]$ hiveservices.sh start </span><br></pre></td></tr></table></figure><blockquote><p>也可以简单启动</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop202 hive]$ nohup hive --service metastore 2&gt;&amp;1 &amp; </span><br><span class="line">[root@hadoop202 hive]$ nohup hive --service hiveserver2 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><h2 id="Hive常用交互命令"><a href="#Hive常用交互命令" class="headerlink" title="Hive常用交互命令"></a>Hive常用交互命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop102 hive]$ bin/hive -help usage: hive</span><br><span class="line">-d,--define &lt;key=value&gt;Variable subsitution to apply to hive</span><br><span class="line">commands. e.g. -d A=B or --define A=B</span><br><span class="line">--database &lt;databasename&gt;Specify the database to use</span><br><span class="line">-e &lt;quoted-query-string&gt;SQL from command line</span><br><span class="line">-f &lt;filename&gt;SQL from files</span><br><span class="line">-H,--helpPrint help information</span><br><span class="line">--hiveconf &lt;property=value&gt;Use value for given property</span><br><span class="line">--hivevar &lt;key=value&gt;Variable subsitution to apply to hive</span><br><span class="line">commands. e.g. --hivevar A=B</span><br><span class="line">-i &lt;filename&gt;Initialization SQL file</span><br><span class="line">-S,--silentSilent mode in interactive shell</span><br><span class="line">-v,--verboseVerbose mode (echo executed SQL to the console)</span><br></pre></td></tr></table></figure><ol><li><code>-e</code>不进入 hive 的交互窗口执行 sql 语句<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop102 hive]$ bin/hive -e &quot;select id from student;&quot; </span><br></pre></td></tr></table></figure></li><li><code>-f</code>执行脚本中 sql 语句<br>（1）在<code>/opt/module/hive/</code>下创建 datas 目录并在 datas 目录下创建 <code>hivef.sql</code> 文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop102 datas]$ touch hivef.sql </span><br></pre></td></tr></table></figure>（2）文件中写入正确的 sql 语句<br><code>select *from student;</code><br>（3）执行文件中的 sql 语句<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop102 hive]$ bin/hive -f /opt/module/hive/datas/hivef.sql </span><br></pre></td></tr></table></figure>（4）执行文件中的 sql 语句并将结果写入文件中<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop102 hive]$ bin/hive -f /opt/module/hive/datas/hivef.sql  &gt; /opt/module/datas/hive_result.txt</span><br></pre></td></tr></table></figure></li></ol><h2 id="Hive其他命令操作"><a href="#Hive其他命令操作" class="headerlink" title="Hive其他命令操作"></a>Hive其他命令操作</h2><ol><li>退出 hive 窗口：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive(default)&gt;exit; </span><br><span class="line">hive(default)&gt;quit;</span><br></pre></td></tr></table></figure></li><li>在 hive cli 命令窗口中如何查看 hdfs 文件系统<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive(default)&gt;dfs -ls /;</span><br></pre></td></tr></table></figure></li><li>查看在 hive 中输入的所有历史命令<br>（1）进入到当前用户的根目录 /root 或/home/atguigu<br>（2）查看. hivehistory 文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop102 ~]$ cat .hivehistory </span><br></pre></td></tr></table></figure></li></ol><h2 id="Hive-常见属性配置"><a href="#Hive-常见属性配置" class="headerlink" title="Hive 常见属性配置"></a>Hive 常见属性配置</h2><h3 id="Hive-运行日志信息配置"><a href="#Hive-运行日志信息配置" class="headerlink" title="Hive 运行日志信息配置"></a>Hive 运行日志信息配置</h3><ol><li>Hive 的 log 默认存放在<code>/tmp/root/hive.log</code> 目录下（当前用户名下）<br>（1）修改<code>/opt/module/hive/conf/hive-log4j2.properties.template</code>  文件名称为 <code>hive-log4j2.properties</code><br>（2）在 <code>hive-log4j2.properties</code> 文件中修改 log 存放位置<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">hive.log.dir</span>=<span class="string">/opt/module/hive/logs </span></span><br></pre></td></tr></table></figure><h3 id="打印-当前库-和-表头"><a href="#打印-当前库-和-表头" class="headerlink" title="打印 当前库 和 表头"></a>打印 当前库 和 表头</h3>在 hive-site.xml 中加入如下两个配置:<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.cli.print.header<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.cli.print.current.db<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="参数配置方式"><a href="#参数配置方式" class="headerlink" title="参数配置方式"></a>参数配置方式</h3><ol><li>查看当前所有的配置信息<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt;set; </span><br></pre></td></tr></table></figure></li><li>参数的配置三种方式</li></ol><ul><li><p>(1)配置文件方式 默认配置文件：<code>hive-default.xml</code> 用户自定义配置文件：<code>hive-site.xml</code></p><blockquote><p>注意：用户自定义配置会覆盖默认配置。另外，<code>Hive</code> 也会读入 <code>Hadoop</code> 的配置，因为 <code>Hive</code> 是作为 <code>Hadoop</code> 的客户端启动的，<code>Hive</code> 的配置会覆盖 <code>Hadoop</code> 的配置。配置文件的设定对本 机启动的所有 <code>Hive</code> 进程都有效。</p></blockquote></li><li><p>(2)命令行参数方式<br>启动 <code>Hive</code> 时，可以在命令行添加<code>-hiveconf param=value</code> 来设定参数。<br>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop103 hive]$ bin/hive -hiveconf mapred.reduce.tasks=10; </span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：仅对本次hive启动有效</strong> 查看参数设置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; set mapred.reduce.tasks; </span><br></pre></td></tr></table></figure><ul><li>(3)参数声明方式<br>可以在 HQL 中使用 SET 关键字设定参数<br>例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; set mapred.reduce.tasks=100; </span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：仅对本次 hive 启动有效。</strong> 查看参数设置</p><pre><code>hive (default)&gt; set mapred.reduce.tasks;</code></pre><blockquote><p>上述三种设定方式的优先级依次递增。即<code>配置文件&lt;命令行参数&lt;参数声明</code>。<strong>注意某些系统级的参数，例如 <code>log4j</code> 相关的设定，必须用前两种方式设定，因为那些参数的读取在会话建立以前已经完成了。</strong></p></blockquote><h1 id="Hive-数据类型"><a href="#Hive-数据类型" class="headerlink" title="Hive 数据类型"></a>Hive 数据类型</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><img src="/img/Hive/Hive%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"><br>对于 Hive 的 String 类型相当于数据库的 varchar 类型，该类型是一个可变的字符串，不 过它不能声明其中最多能存储多少个字符，理论上它可以存储 2GB 的字符数。</p><h2 id="集合数据类型"><a href="#集合数据类型" class="headerlink" title="集合数据类型"></a>集合数据类型</h2><p><img src="/img/Hive/%E9%9B%86%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"><br>Hive 有三种复杂数据类型 <code>ARRAY</code>、<code>MAP</code> 和 <code>STRUCT</code>。ARRAY 和 MAP 与 Java 中的 Array 和 Map 类似，而 STRUCT 与 C 语言中的 Struct 类似，它封装了一个命名字段集合，复杂数据 类型允许任意层次的嵌套。</p><ol><li>案例实操<br>（1）假设某表有如下一行，我们用 JSON 格式来表示其数据结构。在 Hive 下访问的格式为<br><img src="/img/Hive/%E9%9B%86%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B.png"></li></ol><p>（2）基于上述数据结构，我们在 Hive 里创建对应的表，并导入数据。 创建本地测试文件 test.txt<br><img src="/img/Hive/test.png"><br>注意：MAP，STRUCT 和 ARRAY 里的元素间关系都可以用同一个字符表示，这里用“_”。</p>]]></content>
      
      
      <categories>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis的学习</title>
      <link href="/2022/04/28/redis%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/04/28/redis%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis6"><a href="#Redis6" class="headerlink" title="Redis6"></a>Redis6</h1><h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><blockquote><p>本次的安装版本为    <code>6.2.1 for Linux（redis-6.2.1.tar.gz）</code></p></blockquote><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>安装C 语言的编译环境</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br><span class="line">yum install -y devtoolset-8-toolchain</span><br><span class="line">scl enable devtoolset-8 bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试gcc版本"><a href="#测试gcc版本" class="headerlink" title="测试gcc版本"></a>测试gcc版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure><p><img src="/img/redis6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220428160423.png"></p><h3 id="解压redis"><a href="#解压redis" class="headerlink" title="解压redis"></a>解压redis</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf redis-6.2.1.tar.gz</span><br></pre></td></tr></table></figure><h3 id="进入解压后的redis目录"><a href="#进入解压后的redis目录" class="headerlink" title="进入解压后的redis目录"></a>进入解压后的redis目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd redis-6.2.1</span><br></pre></td></tr></table></figure><h3 id="执行命令编译和安装"><a href="#执行命令编译和安装" class="headerlink" title="执行命令编译和安装"></a>执行命令编译和安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="安装目录：-usr-local-bin"><a href="#安装目录：-usr-local-bin" class="headerlink" title="安装目录：/usr/local/bin"></a>安装目录：/usr/local/bin</h3><p>查看默认安装目录：</p><ul><li>redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何</li><li>redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲</li><li>redis-check-dump：修复有问题的dump.rdb文件</li><li>redis-sentinel：Redis集群使用</li><li>redis-server：Redis服务器启动命令</li><li>redis-cli：客户端，操作入口<h3 id="复制解压文件中的redis-conf到指定目录"><a href="#复制解压文件中的redis-conf到指定目录" class="headerlink" title="复制解压文件中的redis.conf到指定目录"></a>复制解压文件中的redis.conf到指定目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp redis.conf /etc/redis.conf</span><br></pre></td></tr></table></figure><h3 id="修改-etc-redis-conf"><a href="#修改-etc-redis-conf" class="headerlink" title="修改/etc/redis.conf"></a>修改/etc/redis.conf</h3>daemonize yes<h3 id="后台启动redis"><a href="#后台启动redis" class="headerlink" title="后台启动redis"></a>后台启动redis</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure><img src="/img/redis6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220428175930.png"><h3 id="客户端连接测试"><a href="#客户端连接测试" class="headerlink" title="客户端连接测试"></a>客户端连接测试</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/redis-cli</span><br></pre></td></tr></table></figure><img src="/img/redis6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220428180122.png"><h3 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br></pre></td></tr></table></figure><img src="/img/redis6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220428180340.png"><h3 id="redis关闭"><a href="#redis关闭" class="headerlink" title="redis关闭"></a>redis关闭</h3>单实例关闭：redis-cli shutdown<br>多实例关闭，指定端口关闭：redis-cli -p 6379 shutdown<br>也可以 kill -9 对应进程号<h3 id="Redis相关知识"><a href="#Redis相关知识" class="headerlink" title="Redis相关知识"></a>Redis相关知识</h3></li><li>默认16个数据库，类似数组下标从0开始，初始<strong>默认使用0号库</strong></li><li>使用命令 <code>select</code> dbid 来切换数据库。如: <code>select 8 </code></li><li>统一密码管理，所有库同样密码。</li><li><code>dbsize</code>查看当前数据库的key的数量</li><li><code>flushdb</code>清空当前库</li><li><code>flushall</code>通杀全部库</li></ul><h2 id="常用五大数据类型"><a href="#常用五大数据类型" class="headerlink" title="常用五大数据类型"></a>常用五大数据类型</h2><h3 id="Redis键-key"><a href="#Redis键-key" class="headerlink" title="Redis键(key)"></a>Redis键(key)</h3><ul><li><code>keys *</code>查看当前库所有key    (匹配：keys *1)</li><li><code>exists key</code>判断某个key是否存在 (存在返回1，不存在返回0)</li><li><code>type key</code> 查看你的key是什么类型</li><li><code>del key </code>      删除指定的key数据</li><li><code>unlink key </code>  根据value选择非阻塞删除<br>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</li><li><code>expire key 10</code>   10秒钟：为给定的key设置过期时间 (返回正数多少秒过期，-2表示过期，-1表示永不过期)</li><li><code>ttl key</code> 查看还有多少秒过期，-1表示永不过期，-2表示已过期</li><li><code>select</code>命令切换数据库</li><li><code>dbsize</code>查看当前数据库的key的数量</li><li><code>flushdb</code>清空当前库</li><li><code>flushall</code>通杀全部库</li></ul><h3 id="Redis字符串-String"><a href="#Redis字符串-String" class="headerlink" title="Redis字符串(String)"></a>Redis字符串(String)</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。<br>String类型<strong>是二进制安全的</strong>。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。<br>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是<strong>512M</strong></p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li><code>set   &lt;key&gt;&lt;value&gt;</code>添加键值对</li></ul><p>*NX：当数据库中key不存在时，可以将key-value添加数据库<br>*XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥<br>*EX：key的超时秒数<br>*PX：key的超时毫秒数，与EX互斥</p><ul><li><code>get   &lt;key&gt;</code>查询对应键值</li><li><code>append  &lt;key&gt;&lt;value&gt;</code>将给定的<code>&lt;value&gt; </code>追加到原值的末尾 (返回value长度)</li><li><code>strlen  &lt;key&gt;</code>获得值的长度</li><li><code>setnx  &lt;key&gt;&lt;value&gt;</code>只有在 key 不存在时    设置 key 的值(成功返回1,失败返回0)</li><li><code>incr  &lt;key&gt;</code>将 key 中储存的数字值增1，只能对数字值操作，如果为空，新增值为1</li><li><code>decr  &lt;key&gt;</code>将 key 中储存的数字值减1，只能对数字值操作，如果为空，新增值为-1</li><li><code>incrby / decrby  &lt;key&gt;&lt;步长&gt;</code>将 key 中储存的数字值增减。自定义步长。<br><img src="/img/redis6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220428220538.png"><br><img src="/img/redis6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220428220551.png"></li><li><code>mset  &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;  ..... </code>同时设置一个或多个 key-value对  </li><li><code>mget  &lt;key1&gt;&lt;key2&gt;&lt;key3&gt; .....</code>同时获取一个或多个 value  </li><li><code>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;  .....</code> 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。<strong>原子性，有一个失败则都失败</strong></li><li><code>getrange  &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;</code>获得值的范围，类似java中的substring，前包，后包(左闭右闭，返回截断字符串)</li><li><code>setrange  &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</code>用 <code>&lt;value&gt;</code>  覆写<code>&lt;key&gt;</code>所储存的字符串值，从<code>&lt;起始位置&gt;</code>开始(索引从0开始)。</li><li><code>setex  &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;</code>设置键值的同时，设置过期时间，单位秒。</li><li><code>getset &lt;key&gt;&lt;value&gt;</code>以新换旧，设置了新值同时获得旧值。<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.<br><img src="/img/redis6/1.png"><br>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度<strong>小于1M</strong>时，扩容都是<strong>加倍现有的空间</strong>，如果<strong>超过1M</strong>，扩容时一次只会<strong>多扩1M</strong>的空间。需要注意的是字符串<strong>最大长度为512M</strong>。</li></ul><h3 id="Redis列表-List"><a href="#Redis列表-List" class="headerlink" title="Redis列表(List)"></a>Redis列表(List)</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>单键多值<br>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br>它的底层实际是个<strong>双向链表</strong>，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。<br><img src="/img/redis6/2.jpg"></p><h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li><code>lpush/rpush  &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ....</code> 从左边/右边插入一个或多个值。</li><li><code>lpop/rpop  &lt;key&gt;</code>从左边/右边吐出一个值。<strong>值在键在，值光键亡</strong>。</li><li><code>rpoplpush  &lt;key1&gt;&lt;key2&gt;从&lt;key1&gt;</code>列表右边吐出一个值，插到<code>&lt;key2&gt;</code>列表左边。</li><li><code>lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;</code>按照索引下标获得元素(从左到右)</li><li><code>lrange mylist 0 -1   </code>0左边第一个，-1右边第一个，（0-1表示获取所有）</li><li><code>lindex &lt;key&gt;&lt;index&gt;</code>按照索引下标获得元素(从左到右)</li><li><code>llen &lt;key&gt;</code>获得列表长度 </li><li><code>linsert &lt;key&gt;  before/after &lt;value&gt;&lt;newvalue&gt;</code>在<code>&lt;value&gt;</code>的后面插入<code>&lt;newvalue&gt;</code>插入值</li><li><code>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;</code>从左边删除n个value(从左到右)</li><li><code>lset&lt;key&gt;&lt;index&gt;&lt;value&gt;</code>将列表key下标为index的值替换成value<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4>List的数据结构为快速链表quickList。<br>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。<br>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。<br>当数据量比较多的时候才会改成quicklist。<br>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。<br><img src="/img/redis6/3.png"><br>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</li></ul><h3 id="Redis集合-Set"><a href="#Redis集合-Set" class="headerlink" title="Redis集合(Set)"></a>Redis集合(Set)</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。<br><strong>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1)。</strong><br>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p><h4 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li><code>sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ..... </code>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</li><li><code>smembers &lt;key&gt;</code>取出该集合的所有值。</li><li><code>sismember &lt;key&gt;&lt;value&gt;</code>判断集合<code>&lt;key&gt;</code>是否为含有该<code>&lt;value&gt;</code>值，有1，没有0</li><li><code>scard&lt;key&gt;</code>返回该集合的元素个数。</li><li><code>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; .... </code>删除集合中的某个元素。</li><li><code>spop &lt;key&gt;</code>随机从该集合中吐出一个值。</li><li><code>srandmember &lt;key&gt;&lt;n&gt;</code>随机从该集合中取出n个值。不会从集合中删除 。</li><li><code>smove &lt;source&gt;&lt;destination&gt;</code>value把集合中一个值从一个集合移动到另一个集合</li><li><code>sinter &lt;key1&gt;&lt;key2&gt;</code>返回两个集合的交集元素。</li><li><code>sunion &lt;key1&gt;&lt;key2&gt;</code>返回两个集合的并集元素。</li><li><code>sdiff &lt;key1&gt;&lt;key2&gt;</code>返回两个集合的差集元素(key1中的，不包含key2中的)<h4 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h4>Set数据结构是dict字典，字典是用哈希表实现的。<br>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</li></ul><h3 id="Redis哈希-Hash"><a href="#Redis哈希-Hash" class="headerlink" title="Redis哈希(Hash)"></a>Redis哈希(Hash)</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>Redis hash 是一个键值对集合。<br>Redis hash是一个string类型的<code>field</code>和<code>value</code>的映射表，hash特别适合用于存储对象。<br>类似Java里面的<code>Map&lt;String,Object&gt;</code><br>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储<br>主要有以下2种存储方式：<br><img src="/img/redis6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220429135823.png"><br><img src="/img/redis6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220429135835.png"></p><h4 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li><code>hset &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>给<code>&lt;key&gt;</code>集合中的 <code> &lt;field&gt;</code>键赋值<code>&lt;value&gt;</code></li><li><code>hget &lt;key1&gt;&lt;field&gt;从&lt;key1&gt;</code>集合<field>取出 value </li><li><code>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;... </code>批量设置hash的值</li><li><code>hexists&lt;key1&gt;&lt;field&gt;</code>查看哈希表 key 中，给定域 field 是否存在。 </li><li><code>hkeys &lt;key&gt;</code>列出该hash集合的所有field</li><li><code>hvals &lt;key&gt;</code>列出该hash集合的所有value</li><li><code>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;</code>为哈希表 key 中的域 field 的值加上增量 1   -1</li><li><code>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .<h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</li></ul><h3 id="Redis有序集合Zset-sorted-set"><a href="#Redis有序集合Zset-sorted-set" class="headerlink" title="Redis有序集合Zset(sorted set)"></a>Redis有序集合Zset(sorted set)</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>Redis有序集合zset与普通集合set非常相似，是一个<strong>没有重复元素</strong>的字符串集合。<br>不同之处是有序集合的每个成员都关联了一个<strong>评分（score）</strong>,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。<strong>集合的成员是唯一的，但是评分可以是重复了</strong> 。<br>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。<br>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p><h4 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li><code>zadd  &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…</code>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</li><li><code>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;  [WITHSCORES]   </code>返回有序集 key 中，下标在<code>&lt;start&gt;``&lt;stop&gt;</code>之间的元素<br>带WITHSCORES，可以让分数一起和值返回到结果集。</li><li><code>zrangebyscore key minmax [withscores] [limit offset count]</code>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 </li><li><code>zrevrangebyscore key maxmin [withscores] [limit offset count]  </code>同上，改为从大到小排列。 </li><li><code>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;</code>为元素的score加上增量</li><li><code>zrem  &lt;key&gt;&lt;value&gt;</code>删除该集合下，指定值的元素 </li><li><code>zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;</code>统计该集合，分数区间内的元素个数 </li><li><code>zrank &lt;key&gt;&lt;value&gt;</code>返回该值在集合中的排名，从0开始。<h4 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h4>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构<code>Map&lt;String, Double&gt;</code>，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。<br>zset底层使用了两个数据结构<br>（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。<br>（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。<h4 id="跳跃表（跳表）"><a href="#跳跃表（跳表）" class="headerlink" title="跳跃表（跳表）"></a>跳跃表（跳表）</h4></li></ul><ol><li>简介<br>跳表全称叫做跳跃表，简称跳表。 跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。 跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。 跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。<br>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</li><li>实例<br>对比有序链表和跳跃表，从链表中查询出51<br>（1）    有序链表<br><img src="/img/redis6/5.png"><br>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。<br>（2）    跳跃表<br><img src="/img/redis6/4.png"><br>从第2层开始，1节点比51节点小，向后比较。<br>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层<br>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下<br>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</li></ol><p>从此可以看出跳跃表比有序链表效率要高</p><h2 id="Redis配置文件介绍"><a href="#Redis配置文件介绍" class="headerlink" title="Redis配置文件介绍"></a>Redis配置文件介绍</h2><p>前文教程存储位置：/etc/redis.conf</p><h3 id="Units单位"><a href="#Units单位" class="headerlink" title="Units单位"></a>Units单位</h3><p>配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit<br>大小写不敏感<br><img src="/img/redis6/6.jpg"></p><h3 id="INCLUDES包含"><a href="#INCLUDES包含" class="headerlink" title="INCLUDES包含"></a>INCLUDES包含</h3><p><img src="/img/redis6/7.jpg"><br>类似jsp中的include，多实例的情况可以把公用的配置文件提取出来</p><h3 id="网络相关配置"><a href="#网络相关配置" class="headerlink" title="网络相关配置"></a>网络相关配置</h3><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>默认情况bind=127.0.0.1只能接受本机的访问请求<br>不写(注释)的情况下，无限制接受任何ip地址的访问<br>生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉<br><strong>如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应</strong><br><img src="/img/redis6/8.jpg"></p><h4 id="protected-mode"><a href="#protected-mode" class="headerlink" title="protected-mode"></a>protected-mode</h4><p>将本机访问保护模式设置no【默认为yes,no为关闭保护模式，允许远程访问】<br><img src="/img/redis6/9.jpg"></p><h4 id="Port"><a href="#Port" class="headerlink" title="Port"></a>Port</h4><p>端口号，默认 6379<br><img src="/img/redis6/10.jpg"></p><h4 id="tcp-backlog"><a href="#tcp-backlog" class="headerlink" title="tcp-backlog"></a>tcp-backlog</h4><p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。<br>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。<br>注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果<br><img src="/img/redis6/11.jpg"></p><h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4><p>一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。<strong>即永不关闭。</strong><br><img src="/img/redis6/12.jpg"></p><h4 id="tcp-keepalive"><a href="#tcp-keepalive" class="headerlink" title="tcp-keepalive"></a>tcp-keepalive</h4><p>对访问客户端的一种<strong>心跳检测</strong>，每个n秒检测一次。<br>单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60<br><img src="/img/redis6/13.jpg"></p><h3 id="GENERAL"><a href="#GENERAL" class="headerlink" title="GENERAL"></a>GENERAL</h3><h4 id="daemonize"><a href="#daemonize" class="headerlink" title="daemonize"></a>daemonize</h4><p>是否为后台进程，设置为yes<br>守护进程，后台启动<br><img src="/img/redis6/14.jpg"></p><h4 id="pidfile"><a href="#pidfile" class="headerlink" title="pidfile"></a>pidfile</h4><p>存放pid文件的位置，每个实例会产生一个不同的pid文件<br><img src="/img/redis6/15.jpg"></p><h4 id="loglevel"><a href="#loglevel" class="headerlink" title="loglevel"></a>loglevel</h4><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为<strong>notice</strong><br><strong>四个级别根据使用阶段来选择，生产环境选择notice 或者warning</strong><br><img src="/img/redis6/16.jpg"></p><h4 id="logfile"><a href="#logfile" class="headerlink" title="logfile"></a>logfile</h4><p>日志文件名称<br><img src="/img/redis6/17.jpg"></p><h4 id="databases-16"><a href="#databases-16" class="headerlink" title="databases 16"></a>databases 16</h4><p>设定库的数量 默认16，默认数据库为0，可以使用<code>SELECT &lt;dbid&gt;</code>命令在连接上指定数据库id<br><img src="/img/redis6/18.jpg"></p><h3 id="SECURITY安全"><a href="#SECURITY安全" class="headerlink" title="SECURITY安全"></a>SECURITY安全</h3><h4 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h4><p><img src="/img/redis6/19.jpg"></p><h3 id="LIMITS限制"><a href="#LIMITS限制" class="headerlink" title="LIMITS限制"></a>LIMITS限制</h3><h4 id="maxclients"><a href="#maxclients" class="headerlink" title="maxclients"></a>maxclients</h4><ul><li>   设置redis同时可以与多少个客户端进行连接。</li><li>   默认情况下为10000个客户端。</li><li>   如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。<br><img src="/img/redis6/20.jpg"><h4 id="maxmemory"><a href="#maxmemory" class="headerlink" title="maxmemory"></a>maxmemory</h4></li><li>   建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机</li><li>   设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过<strong>maxmemory-policy</strong>来指定。</li><li>   如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</li><li>   但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。<br><img src="/img/redis6/21.jpg"><h4 id="maxmemory-policy"><a href="#maxmemory-policy" class="headerlink" title="maxmemory-policy"></a>maxmemory-policy</h4></li><li>   volatile-lru：使用LRU算法移除key，只对设置了<strong>过期时间</strong>的键；（最近最少使用）</li><li>   allkeys-lru：在所有集合key中，使用LRU算法移除key</li><li>   volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键</li><li>   allkeys-random：在所有集合key中，移除随机的key</li><li>   volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</li><li>   noeviction：不进行移除。针对写操作，只是返回错误信息<br><img src="/img/redis6/22.jpg"><h4 id="maxmemory-samples"><a href="#maxmemory-samples" class="headerlink" title="maxmemory-samples"></a>maxmemory-samples</h4></li><li>   设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。</li><li>   一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。<br><img src="/img/redis6/23.jpg"></li></ul><h2 id="Redis的发布和订阅"><a href="#Redis的发布和订阅" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h2><h3 id="什么是发布和订阅"><a href="#什么是发布和订阅" class="headerlink" title="什么是发布和订阅"></a>什么是发布和订阅</h3><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p><p>Redis 客户端可以订阅任意数量的频道。</p><h3 id="Redis的发布和订阅-1"><a href="#Redis的发布和订阅-1" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h3><ol><li>客户端可以订阅频道如下图<br><img src="/img/redis6/24.png"></li><li>当给这个频道发布消息后，消息就会发送给订阅的客户端<br><img src="/img/redis6/25.png"><h3 id="发布订阅命令行实现"><a href="#发布订阅命令行实现" class="headerlink" title="发布订阅命令行实现"></a>发布订阅命令行实现</h3></li><li>打开一个客户端订阅channel1<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE channel1</span><br></pre></td></tr></table></figure><img src="/img/redis6/26.png"></li><li>打开另一个客户端，给channel1发布消息hello<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish channel1 hello</span><br></pre></td></tr></table></figure><img src="/img/redis6/27.png"><br>返回的1是订阅者数量</li><li>打开第一个客户端可以看到发送的消息<br><img src="/img/redis6/28.png"><br>注：发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息</li></ol><h2 id="Redis新数据类型"><a href="#Redis新数据类型" class="headerlink" title="Redis新数据类型"></a>Redis新数据类型</h2><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><p>现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图<br><img src="/img/redis6/29.png"><br>合理地使用操作位能够有效地提高内存使用率和开发效率。<br>    Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：<br>（1）    Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。<br>（2）    Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。<br><img src="/img/redis6/30.png"></p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><ol><li>setbit<br>（1）格式<br><code>setbit&lt;key&gt;&lt;offset&gt;&lt;value&gt;</code>设置Bitmaps中某个偏移量的值（0或1）<br><img src="/img/redis6/31.png"></li></ol><p>*offset:偏移量从0开始<br>（2）实例<br>每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。<br>设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，userid=1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图<br><img src="/img/redis6/32.png"><br>unique:users:20201106代表2020-11-06这天的独立访问用户的Bitmaps<br><img src="/img/redis6/33.png"><br><strong>注：</strong><br>很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。<br>在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。</p><ol start="2"><li>getbit<br>（1）格式<br><code>getbit&lt;key&gt;&lt;offset&gt;</code>获取Bitmaps中某个偏移量的值<br><img src="/img/redis6/34.png"><br>获取键的第offset位的值（从0开始算）<br>（2）实例<br>获取id=8的用户是否在2020-11-06这天访问过， 返回0说明没有访问过：<br><img src="/img/redis6/35.png"></li></ol><p><strong>注：</strong>因为100根本不存在，所以也是返回0<br>3. bitcount<br>统计<strong>字符串</strong>被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。<br>（1）格式<br><code>bitcount&lt;key&gt;[start end] </code>统计字符串从start字节到end字节比特值为1的数量<br><img src="/img/redis6/36.png"><br>（2）实例<br>计算2022-11-06这天的独立访问用户数量<br><img src="/img/redis6/37.png"><br>start和end代表起始和结束字节数， 下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19。<br><img src="/img/redis6/38.png"></p><p><strong>举例： K1 【01000001 01000000  00000000 00100001】，对应【0，1，2，3】</strong><br>bitcount K1 1 2  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000<br>–》bitcount K1 1 2 　　–》1</p><p>bitcount K1 1 3  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000 00100001<br>–》bitcount K1 1 3　　–》3</p><p>bitcount K1 0 -2  ： 统计下标0到下标倒数第2，字节组中bit=1的个数，即01000001  01000000   00000000<br>–》bitcount K1 0 -2　　–》3</p><p> 注意：redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置。</p><ol start="4"><li>bitop<br>(1)格式<br><code>bitop  and(or/not/xor) &lt;destkey&gt; [key…]</code><br><img src="/img/redis6/39.png"><br>bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。</li></ol><p>(2)实例<br>2020-11-04 日访问网站的userid=1,2,5,9。<br>setbit unique:users:20201104 1 1<br>setbit unique:users:20201104 2 1<br>setbit unique:users:20201104 5 1<br>setbit unique:users:20201104 9 1</p><p>2020-11-03 日访问网站的userid=0,1,4,9。<br>setbit unique:users:20201103 0 1<br>setbit unique:users:20201103 1 1<br>setbit unique:users:20201103 4 1<br>setbit unique:users:20201103 9 1</p><p>计算出两天都访问过网站的用户数量<br>bitop and unique:users:and:20201104_03<br> unique:users:20201103unique:users:20201104<br><img src="/img/redis6/40.png"><br><img src="/img/redis6/41.png"><br>计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种） ， 可以使用or求并集<br><img src="/img/redis6/42.png"></p><h4 id="6-1-3-Bitmaps与set对比"><a href="#6-1-3-Bitmaps与set对比" class="headerlink" title="6.1.3.    Bitmaps与set对比"></a>6.1.3.    Bitmaps与set对比</h4><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表<br><img src="/img/redis6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220429225628.png"><br>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的<br><img src="/img/redis6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220429225801.png"><br>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。<br><img src="/img/redis6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220429225830.png"></p><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><h4 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h4><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。<br>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。<br>解决基数问题有很多种方案：<br>（1）数据存储在MySQL表中，使用distinct count计算不重复个数<br>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理<br>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。<br>能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog<br>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。<br>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。<br>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>什么是基数?<br>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><ol><li>pfadd<br>（1）格式<br><code>pfadd &lt;key&gt;&lt; element&gt; [element ...]  </code> 添加指定元素到 HyperLogLog 中<br><img src="/img/redis6/43.png"></li></ol><p>（2）实例</p><pre><code>将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。</code></pre><p> <img src="/img/redis6/44.png"><br>2. pfcount<br>（1）格式<br><code>pfcount&lt;key&gt; [key ...] </code>计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可<br><img src="/img/redis6/45.png"><br>（2）实例<br><img src="/img/redis6/46.png"></p><ol start="3"><li>pfmerge<br>（1）格式<br><code>pfmerge&lt;destkey&gt;&lt;sourcekey&gt; [sourcekey ...] </code> 将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得<br><img src="/img/redis6/47.png"></li></ol><p>（2）实例<br><img src="/img/redis6/48.png"></p><h3 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h3><h4 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h4><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><ol><li>geoadd</li></ol><p>（1）格式<br><code>geoadd&lt;key&gt;&lt; longitude&gt;&lt;latitude&gt;&lt;member&gt; [longitude latitude member...] </code>  添加地理位置（经度，纬度，名称）<br> <img src="/img/redis6/49.png"></p><p>（2）实例<br>geoadd china:city 121.47 31.23 shanghai<br>geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing<br> <img src="/img/redis6/50.png"><br>两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。<br>有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。<br>当坐标位置超出指定范围时，该命令将会返回一个错误。<br>已经添加的数据，是无法再次往里面添加的。</p><ol start="2"><li>geopos<br>（1）格式<br><code>geopos  &lt;key&gt;&lt;member&gt; [member...]  </code>获得指定地区的坐标值<br><img src="/img/redis6/51.png"></li></ol><p>（2）实例<br> <img src="/img/redis6/52.png"></p><ol start="3"><li>geodist</li></ol><p>（1）格式<br><code>geodist&lt;key&gt;&lt;member1&gt;&lt;member2&gt;  [m|km|ft|mi ] </code> 获取两个位置之间的直线距离<br><img src="/img/redis6/53.png"></p><p>（2）实例<br>获取两个位置之间的直线距离<br><img src="/img/redis6/54.png"><br>单位：<br>m 表示单位为米(默认值)。<br>km 表示单位为千米。<br>mi 表示单位为英里。<br>ft 表示单位为英尺。<br>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</p><ol start="4"><li>georadius<br>（1）格式<br><code>georadius&lt;key&gt;&lt; longitude&gt;&lt;latitude&gt;radius  m|km|ft|mi</code>   以给定的经纬度为中心，找出某一半径内的元素<br><img src="/img/redis6/55.png"><br>经度 纬度 距离 单位</li></ol><p>（2）实例<br> <img src="/img/redis6/56.png"></p><h2 id="Redis-Jedis-测试"><a href="#Redis-Jedis-测试" class="headerlink" title="Redis_Jedis_测试"></a>Redis_Jedis_测试</h2><h3 id="引入Jedis依赖包"><a href="#引入Jedis依赖包" class="headerlink" title="引入Jedis依赖包"></a>引入Jedis依赖包</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="连接Redis注意事项"><a href="#连接Redis注意事项" class="headerlink" title="连接Redis注意事项"></a>连接Redis注意事项</h3><p>禁用Linux的防火墙：Linux(CentOS7)里执行命令<br>systemctl stop/disable firewalld.service<br>redis.conf中注释掉bind 127.0.0.1 ,然后 protected-mode no</p><h2 id="SpringBoot-redis整合"><a href="#SpringBoot-redis整合" class="headerlink" title="SpringBoot-redis整合"></a>SpringBoot-redis整合</h2><h3 id="Pom文件引入依赖"><a href="#Pom文件引入依赖" class="headerlink" title="Pom文件引入依赖"></a>Pom文件引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="application-properties修改配置文件"><a href="#application-properties修改配置文件" class="headerlink" title="application.properties修改配置文件"></a>application.properties修改配置文件</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Redis服务器地址</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">192.168.140.136</span></span><br><span class="line"><span class="comment">#Redis服务器连接端口</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">#Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="meta">spring.redis.database</span>= <span class="string">0</span></span><br><span class="line"><span class="comment">#连接超时时间（毫秒）</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"><span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#连接池中的最小空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><h3 id="添加redis配置类"><a href="#添加redis配置类" class="headerlink" title="添加redis配置类"></a>添加redis配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.redis_springboot.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableCaching</span><span class="comment">//开启缓存</span></span><br><span class="line"><span class="meta">@Configuration</span><span class="comment">//配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">//key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">        <span class="comment">//value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//value hashmap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        <span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SpringBoot缓存注解"><a href="#SpringBoot缓存注解" class="headerlink" title="SpringBoot缓存注解"></a>SpringBoot缓存注解</h3><p>（1）缓存@Cacheable<br>根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。</p><p>查看源码，属性值如下：</p><table><thead><tr><th align="left">属性/方法名</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td align="left">cacheNames</td><td align="left">与 value 差不多，二选一即可</td></tr><tr><td align="left">key</td><td align="left">可选属性，可以使用 SpEL 标签自定义缓存的key</td></tr></tbody></table><p>（2）缓存@CachePut<br>使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库。一般用在新增方法上。</p><p>查看源码，属性值如下：</p><table><thead><tr><th align="left">属性/方法名</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td align="left">cacheNames</td><td align="left">与 value 差不多，二选一即可</td></tr><tr><td align="left">key</td><td align="left">可选属性，可以使用 SpEL 标签自定义缓存的key</td></tr></tbody></table><p>（3）缓存@CacheEvict<br>使用该注解标志的方法，会清空指定的缓存。一般用在更新或者删除方法上</p><p>查看源码，属性值如下：</p><table><thead><tr><th align="left">属性/方法名</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td align="left">cacheNames</td><td align="left">与 value 差不多，二选一即可</td></tr><tr><td align="left">key</td><td align="left">可选属性，可以使用 SpEL 标签自定义缓存的key</td></tr><tr><td align="left">allEntries</td><td align="left">是否清空所有缓存，默认为 false。如果指定为 true，则方法调用后将立即清空所有的缓存</td></tr><tr><td align="left">beforeInvocation</td><td align="left">是否在方法执行前就清空，默认为 false。如果指定为 true，则在方法执行前就会清空缓存</td></tr></tbody></table><p>Java代码注解使用示例【redis缓存注解使用】</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrmBannerServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">CrmBannerMapper</span>, <span class="title">CrmBanner</span>&gt; <span class="keyword">implements</span> <span class="title">CrmBannerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;banner&quot;, key = &quot;&#x27;selectIndexList&#x27;&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CrmBanner&gt; <span class="title">selectIndexList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;CrmBanner&gt; list = baseMapper.selectList(<span class="keyword">new</span> QueryWrapper&lt;CrmBanner&gt;().orderByDesc(<span class="string">&quot;sort&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pageBanner</span><span class="params">(Page&lt;CrmBanner&gt; pageParam, Object o)</span> </span>&#123;</span><br><span class="line">        baseMapper.selectPage(pageParam,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CrmBanner <span class="title">getBannerById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMapper.selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;banner&quot;, allEntries=true)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveBanner</span><span class="params">(CrmBanner banner)</span> </span>&#123;</span><br><span class="line">        baseMapper.insert(banner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;banner&quot;, allEntries=true)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBannerById</span><span class="params">(CrmBanner banner)</span> </span>&#123;</span><br><span class="line">        baseMapper.updateById(banner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;banner&quot;, allEntries=true)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBannerById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        baseMapper.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redisTemplate的使用"><a href="#redisTemplate的使用" class="headerlink" title="redisTemplate的使用"></a>redisTemplate的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.redis_springboot.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//设置值到redis</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        <span class="comment">//从redis获取值</span></span><br><span class="line">        String name = (String) redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Redis-事务-锁机制-秒杀"><a href="#Redis-事务-锁机制-秒杀" class="headerlink" title="Redis_事务_锁机制_秒杀"></a>Redis_事务_锁机制_秒杀</h2><h3 id="Redis的事务定义"><a href="#Redis的事务定义" class="headerlink" title="Redis的事务定义"></a>Redis的事务定义</h3><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>Redis事务的主要作用就是<strong>串联多个命令</strong>防止别的命令插队。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostConstruct注解的使用</title>
      <link href="/2022/04/24/PostConstruct%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/04/24/PostConstruct%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h1><p><code>@PostConstruct</code> 该注解被用来修饰一个<strong>非静态</strong>的<code>void()</code>方法。</p><p>被 <code>@PostConstruct</code> 修饰的方法会在服务器加载 Servlet 的时候运行，并且只会被服务器执行一次。</p><p><code>@PostConstruct</code> 在构造函数之后执行，init（）方法之前执行。</p><p>通常我们会是在 Spring 框架中使用到 <code>@PostConstruct</code> 注解，该注解的方法在整个 Bean 初始化中的执行顺序：<br><code>Constructor(构造方法)</code> -&gt; <code>@Autowired(依赖注入)</code> -&gt; <code>@PostConstruct(注释的方法)</code></p><hr><p>@PostConstruct 注解用于需要在依赖注入完成后执行任何初始化的方法。<br>必须在类投入使用之前调用此方法。 所有支持依赖注入的类都必须支持这个注解。<br>即使类没有请求注入任何资源，也必须调用用 PostConstruct 注释的方法。 这个注解只能注解一种方法。 应用 PostConstruct 注释的方法必须满足以下所有标准：</p><p>该方法不能有任何参数，除非是拦截器，在这种情况下它需要一个由拦截器规范定义的 InvocationContext 对象。<br>在拦截器类上定义的方法必须具有以下签名之一：<br>void &lt;方法&gt;(InvocationContext)<br>对象 (InvocationContext) 抛出异常<br>注意：PostConstruct 拦截器方法不得抛出应用程序异常，但如果相同的拦截器方法除了生命周期事件之外还插入业务或超时方法，则可以声明它抛出检查异常，包括 java.lang.Exception。 如果 PostConstruct 拦截器方法返回一个值，它会被容器忽略。<br>在非拦截器类上定义的方法必须具有以下签名：<br>void &lt;方法&gt;()<br>应用 PostConstruct 的方法可以是 public、protected、package private 或 private。<br>除了应用程序客户端之外，该方法不得是静态的。<br>该方法可能是最终的。<br>如果该方法抛出未经检查的异常，则该类不得投入使用，除非在 EJB 的情况下，EJB 可以处理异常甚至从异常中恢复</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdbc.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt.SecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecuritysConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SecurityManager securityManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecuritysConfig</span><span class="params">(SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.securityManager = securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initStaticSecurityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随手记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手记 </tag>
            
            <tag> Java注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动注入的三种方式以及区别</title>
      <link href="/2022/04/22/%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/04/22/%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Autowire-Resource-Qualifier"><a href="#Autowire-Resource-Qualifier" class="headerlink" title="@Autowire @Resource @Qualifier"></a>@Autowire @Resource @Qualifier</h1><ul><li><p><code>@Autowired</code> 接口只能有一个实现类，通过byType方式注入<br>默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：@Autowired(required=false)</p></li><li><p><code>@Resource</code> 接口可以有多个实现类，先通过byName方式进行匹配，若匹配失败再通过byType方式注入</p></li><li><p><code>@Qualifier</code> 接口可以有多个实现类,可以按实现类的类名进行注入</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随手记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手记 </tag>
            
            <tag> Java注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB</title>
      <link href="/2022/03/16/MongoDB/"/>
      <url>/2022/03/16/MongoDB/</url>
      
        <content type="html"><![CDATA[<h1 id="Centos7安装mongodb"><a href="#Centos7安装mongodb" class="headerlink" title="Centos7安装mongodb"></a>Centos7安装mongodb</h1><h2 id="前往官网下载mongodb的tgz包"><a href="#前往官网下载mongodb的tgz包" class="headerlink" title="前往官网下载mongodb的tgz包"></a>前往官网下载mongodb的tgz包</h2><blockquote><p>选择centos7下的4.4版本tgz包 –&gt; <a href="https://www.mongodb.com/try/download/community">官网</a></p></blockquote><p><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220316170848.png"></p><h2 id="上传至服务器【目录自选】"><a href="#上传至服务器【目录自选】" class="headerlink" title="上传至服务器【目录自选】"></a>上传至服务器【目录自选】</h2><p><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220316172954.png"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用tar -zxvf 目标压缩包 -C 目标目录</span></span><br><span class="line">sudo tar -zxvf mongodb-linux-x86_64-rhel70-4.4.13.tgz -C /usr/local/</span><br><span class="line"><span class="meta">#</span><span class="bash">重新命名</span></span><br><span class="line">sudo mv /usr/local/mongodb-linux-x86_64-rhel70-4.4.13/ /usr/local/mongodb</span><br></pre></td></tr></table></figure><p><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220316174031.png"></p><h2 id="创建数据库目录"><a href="#创建数据库目录" class="headerlink" title="创建数据库目录"></a>创建数据库目录</h2><p>默认情况下 MongoDB 启动后会初始化以下两个目录：</p><ul><li>数据存储目录：/var/lib/mongodb</li><li>日志文件目录：/var/log/mongodb</li></ul><p>我们在mongodb目录下创建对应对应的数据以及日志文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/mongodb</span><br><span class="line"><span class="meta">#</span><span class="bash">创建存放数据的目录</span></span><br><span class="line">sudo mkdir -p data/db</span><br><span class="line"><span class="meta">#</span><span class="bash">创建存放日志的目录</span></span><br><span class="line">sudo mkdir -p logs</span><br><span class="line"><span class="meta">#</span><span class="bash">创建日志记录文件</span></span><br><span class="line"> sudo touch /usr/local/mongodb/logs/mongodb.log</span><br></pre></td></tr></table></figure><h2 id="前台启动"><a href="#前台启动" class="headerlink" title="前台启动"></a>前台启动</h2><p>MongoDB的默认启动方式为前台启动。所谓的前台启动就是MongoDB启动进程后会占用当前的终端窗口。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">切换至指定目录</span></span><br><span class="line">cd /usr/local/mongodb</span><br><span class="line"><span class="meta">#</span><span class="bash">前台启动</span></span><br><span class="line">bin/mongod --dbpath /usr/local/mongodb/data/db/ --logpath /usr/local/mongodb/logs/mongodb.log  --logappend --port 27017 --bind_ip 0.0.0.0</span><br></pre></td></tr></table></figure><ul><li><code>--dbpath</code>：指定数据文件存放目录</li><li><code>--logpath</code>：指定日志文件，注意指定文件不是目录</li><li><code>--logappend</code>：使用追加的方式记录日志</li><li><code>--port</code>：指定端口，默认为27017</li><li><code>--bind_ip</code>：绑定服务IP，若绑定127.0.0.1，则只能本机访问，默认为本机地址</li></ul><h2 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">切换至指定目录</span></span><br><span class="line">cd /usr/local/mongodb</span><br><span class="line"><span class="meta">#</span><span class="bash">后台启动</span></span><br><span class="line">bin/mongod --dbpath /usr/local/mongodb/data/db/ --logpath /usr/local/mongodb/logs/mongodb.log  --logappend --port 27017 --bind_ip 0.0.0.0 --fork</span><br></pre></td></tr></table></figure><p>如果想关掉后台服务只需要尾部添加<code>--shutdown</code></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#数据文件存放目录</span><br><span class="line">dbpath=/usr/local/mongodb/data/db</span><br><span class="line">#日志文件存放目录</span><br><span class="line">logpath=/usr/local/mongodb/logs/mongodb.log</span><br><span class="line">#以追加的方式记录日志</span><br><span class="line">logappend=true</span><br><span class="line">#端口默认为27017</span><br><span class="line">port=27017</span><br><span class="line">#对访问IP地址不做限制，默认为本机地址</span><br><span class="line">bind_ip=0.0.0.0</span><br><span class="line">#以守护进程的方式启用，即在后台运行</span><br><span class="line">fork=true</span><br></pre></td></tr></table></figure><p>以配置文件方式启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/mongod -f bin/mongodb.conf</span><br></pre></td></tr></table></figure><p>如果要关闭同样尾部添加<code>--shutdown</code>即可</p><h2 id="MongoDB函数关闭"><a href="#MongoDB函数关闭" class="headerlink" title="MongoDB函数关闭"></a>MongoDB函数关闭</h2><p>连接MongoDB服务后，切换admin数据库，并使用相关函数关闭服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#连接mongodb</span><br><span class="line">bin/mongo</span><br><span class="line">#切换admin数据库</span><br><span class="line">use admin</span><br><span class="line">#执行以下函数(2选1)即关闭服务</span><br><span class="line">db.shutdownServer()</span><br><span class="line">db.runCommand(&quot;shutdown&quot;)</span><br></pre></td></tr></table></figure><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line">#Mongodb ENVIRONMENT</span><br><span class="line">export MONGODB_HOME=/usr/local/mongodb</span><br><span class="line">#Path后面添加:MONGODB_HOME/bin</span><br><span class="line">#最后（:wq）保存，并source /etc/profile</span><br></pre></td></tr></table></figure><h1 id="MongoDB用户与权限管理"><a href="#MongoDB用户与权限管理" class="headerlink" title="MongoDB用户与权限管理"></a>MongoDB用户与权限管理</h1><h2 id="常用权限"><a href="#常用权限" class="headerlink" title="常用权限"></a>常用权限</h2><table><thead><tr><th align="left">权限</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">read</td><td align="left">允许用户读取指定数据库</td></tr><tr><td align="left">readWrite</td><td align="left">允许用户读写指定数据库</td></tr><tr><td align="left">userAdmin</td><td align="left">允许用户向system.users集合写入，可以在指定数据库里创建、删除和管理用户</td></tr><tr><td align="left">dbAdmin</td><td align="left">允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile</td></tr><tr><td align="left">clusterAdmin</td><td align="left">必须在admin数据库中定义，赋予用户所有切片和复制集相关函数的管理权限</td></tr><tr><td align="left">readAnyDatabase</td><td align="left">必须在admin数据库中定义，赋予用户所有数据库读权限</td></tr><tr><td align="left">readWriteAnyDatabase</td><td align="left">必须在admin数据库中定义，赋予用户所有数据库读写权限</td></tr><tr><td align="left">userAdminAnyDatabase</td><td align="left">必须在admin数据库中定义，赋予用户所有数据库userAdmin权限</td></tr><tr><td align="left">dbAdminAnyDatabase</td><td align="left">必须在admin数据库中定义，赋予用户所有数据库dbAdmin权限</td></tr><tr><td align="left">root</td><td align="left">必须在admin数据库中定义，超级站账号，超级权限</td></tr></tbody></table><h2 id="创建管理用户"><a href="#创建管理用户" class="headerlink" title="创建管理用户"></a>创建管理用户</h2><h3 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看所有数据库</span><br><span class="line">show dbs</span><br><span class="line">#切换数据库</span><br><span class="line">use admin</span><br></pre></td></tr></table></figure><h3 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看用户</span><br><span class="line">show users</span><br></pre></td></tr></table></figure><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建用户</span><br><span class="line">db.createUser(&#123;user:&quot;zzf&quot;,pwd:&quot;zzf&quot;,roles:[&#123;role:&quot;userAdminAnyDatabase&quot;,db:&quot;admin&quot;&#125;]&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在配置文件中添加如下信息，代表开启认证</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#开启身份认证</span><br><span class="line">auth=true</span><br></pre></td></tr></table></figure><h3 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h3><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongo</span><br><span class="line">#切换admin数据库</span><br><span class="line">use admin</span><br><span class="line">#身份认证</span><br><span class="line">db.auth(&quot;zzf&quot;,&quot;zzf&quot;)</span><br><span class="line">#返回1代表认证成功，0认证失败</span><br></pre></td></tr></table></figure><h2 id="创建普通用户"><a href="#创建普通用户" class="headerlink" title="创建普通用户"></a>创建普通用户</h2><p>需求：创建一个test数据库，给这个数据库添加一个用户，用户名为testuser，密码为123456。并授予用户对test数据库的读写操作权限。</p><h3 id="管理员登录数据库"><a href="#管理员登录数据库" class="headerlink" title="管理员登录数据库"></a>管理员登录数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongo</span><br><span class="line">#切换admin数据库</span><br><span class="line">use admin</span><br><span class="line">#身份认证</span><br><span class="line">db.auth(&quot;zzf&quot;,&quot;zzf&quot;)</span><br><span class="line">#返回1代表认证成功，0认证失败</span><br></pre></td></tr></table></figure><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#如果没有数据库，通过use test 也会进行创建test数据库，并进入</span><br><span class="line">use test</span><br><span class="line">#查看当前所在数据库</span><br><span class="line">db</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建用户-1"><a href="#创建用户-1" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建用户</span><br><span class="line">db.createUser(&#123;user:&quot;testuser&quot;,pwd:&quot;123456&quot;,roles:[&#123;role:&quot;readWrite&quot;,db:&quot;test&quot;&#125;]&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="身份认证-1"><a href="#身份认证-1" class="headerlink" title="身份认证"></a>身份认证</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use test</span><br><span class="line">#认证</span><br><span class="line">db.auth(&quot;testuser&quot;,&quot;123456&quot;)</span><br><span class="line">#数据添加</span><br><span class="line">db.user.insert(&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;)</span><br><span class="line">#数据查询</span><br><span class="line">db.user.find()</span><br><span class="line">--result:&#123; &quot;_id&quot; : ObjectId(&quot;6232d4333ed6a208fa727eee&quot;), &quot;name&quot; : &quot;zhangsan&quot; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="更新用户"><a href="#更新用户" class="headerlink" title="更新用户"></a>更新用户</h2><h3 id="更新用户权限"><a href="#更新用户权限" class="headerlink" title="更新用户权限"></a>更新用户权限</h3><p>如果我们需要对已存在的角色进行角色修改，可以使用<code>db.updateUser()</code>函数来更新用户角色。注意：执行该函数需要当前用户具有<code>userAdmin</code>或<code>userAdminAmyDataBase</code>或<code>root</code>角色。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#更新用户权限</span><br><span class="line">db.updateUser(&quot;用户名&quot;,&#123;&quot;roles&quot;:[&#123;&quot;role&quot;:&quot;角色名称&quot;,db:&quot;数据库&quot;&#125;,&#123;&quot;更新项2&quot;:&quot;更新内容&quot;&#125;]&#125;)</span><br></pre></td></tr></table></figure><h3 id="更新密码"><a href="#更新密码" class="headerlink" title="更新密码"></a>更新密码</h3><p>更新用户密码有以下两种方式，更新密码时需要切换到该用户所在数据库。注意：需要使用具有<code>userAdmin</code>或<code>userAdminAnyDatabase</code>或<code>root</code>角色的用户执行：</p><ul><li>使用<code>db.updateUser(&quot;用户名&quot;,&#123;&quot;pwd&quot;:&quot;新密码&quot;&#125;)</code>函数更新密码</li><li>使用<code>db.changeUserPassword(&quot;用户名&quot;,&quot;新密码&quot;)</code>函数更新密码</li></ul><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><p>通过<code>db.dropUser()</code>函数可以删除指定用户，删除成功以后会返回true。删除用户时需要切换到该用户所在的数据库。注意：需要使用具有<code>userAdmin</code>或<code>userAdmiAnyDatabase</code>或<code>root</code>角色的用户才可以删除其他用户。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongo</span><br><span class="line">use admin</span><br><span class="line">db.auth(&quot;zzf&quot;,&quot;123456&quot;)</span><br><span class="line">use test</span><br><span class="line">show users</span><br><span class="line">#删除用户</span><br><span class="line">db.dropUser(&quot;testuser&quot;)</span><br></pre></td></tr></table></figure><h1 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h1><p>关于MongoDB的GUI有很多种，本学习使用Navicat 15</p><h2 id="Navicat-15"><a href="#Navicat-15" class="headerlink" title="Navicat 15"></a>Navicat 15</h2><p><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220317151936.png"></p><h1 id="MongoDB的集合操作"><a href="#MongoDB的集合操作" class="headerlink" title="MongoDB的集合操作"></a>MongoDB的集合操作</h1><h2 id="Database操作"><a href="#Database操作" class="headerlink" title="Database操作"></a>Database操作</h2><h3 id="创建数据库-1"><a href="#创建数据库-1" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>利用<code>use test</code>切换数据库，如果没有则创建并切换</p><h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><blockquote><p>PS:不同的角色显示的数据库不同</p></blockquote><p>使用<code>show dbs</code>或<code>show databases</code>查看所有数据库</p><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p>删除数据库需要切换到需要删除的数据库中，且登录用户具有<code>dbAdminAnyDatabase</code>权限,执行<code>db.dropDatabase()</code></p><h2 id="Collection操作"><a href="#Collection操作" class="headerlink" title="Collection操作"></a>Collection操作</h2><p>MongoDB中的集合是一组文档的集，相当于关系型数据库中的表(table)</p><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><p><code>db.table1</code>创建集合<br><code>db.table1.insert()</code>该指令可以创建集合并且插入文档</p><p>MongoDB使用<code>db.createCollection()</code>函数来创建集合。<br>语法格式：<code>db.createCollection(name,option)</code>。</p><ul><li>name：要创建的集合名称</li><li>option：可选参数，指定有关内存大小和索引的选项<br><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220317153428.png"></li></ul><h3 id="查看集合"><a href="#查看集合" class="headerlink" title="查看集合"></a>查看集合</h3><p><code>show tables</code>或<code>show collections</code>查看集合</p><h3 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h3><p>通过<code>db.COLLECTION_NAME.drop()</code>删除集合</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#示例</span><br><span class="line">db.c1.drop()</span><br></pre></td></tr></table></figure><h2 id="Document操作"><a href="#Document操作" class="headerlink" title="Document操作"></a>Document操作</h2><h3 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h3><h4 id="单条插入"><a href="#单条插入" class="headerlink" title="单条插入"></a>单条插入</h4><p>可以使用<code>insert/insertOne/save</code>插入单条文档：</p><ul><li><code>db.c1.insert(&#123;&quot;name&quot;:&quot;a&quot;&#125;)</code></li><li><code>db.c1.insertOne(&#123;&quot;name&quot;:&quot;a&quot;&#125;)</code></li><li><code>db.c1.save(&#123;&quot;name&quot;:&quot;a&quot;&#125;)</code> 如果指定了<code>_id</code>字段则为修改【如果没有也为添加】，反之等同于<code>insert()</code>方法</li></ul><p>如果JSON格式的文档很长，我们也可以用一个变量操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#示例</span><br><span class="line">user1 = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;zhangsan&quot;,</span><br><span class="line">    &quot;age&quot;:18,</span><br><span class="line">    &quot;hobbies&quot;:[&quot;music&quot;,&quot;read&quot;],</span><br><span class="line">    &quot;addr&quot;:&#123;</span><br><span class="line">        &quot;country&quot;:&quot;China&quot;,</span><br><span class="line">        &quot;city&quot;:&quot;BJ&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.user.insert(user1)</span><br></pre></td></tr></table></figure><h4 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h4><p>可以使用<code>insert/insertMany/save</code>插入多条文档，区别在于把单挑插入时函数参数的对象类型<code>&#123;&#125;</code>变成数组类型<code>[&#123;&#125;,&#123;&#125;]</code>:</p><ul><li><code>db.c1.insert([&#123;name:&quot;a&quot;&#125;,&#123;name:&quot;b&quot;&#125;])</code></li><li><code>db.c1.insertMany([&#123;name:&quot;a&quot;&#125;,&#123;name:&quot;b&quot;&#125;])</code></li><li><code>db.c1.save([&#123;name:&quot;a&quot;&#125;,&#123;name:&quot;b&quot;&#125;])</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#示例代码</span><br><span class="line">user1 = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;LiSA&quot;,</span><br><span class="line">    &quot;age&quot;:18,</span><br><span class="line">    &quot;hobbies&quot;:[&quot;music&quot;,&quot;read&quot;],</span><br><span class="line">    &quot;addr&quot;:&#123;</span><br><span class="line">        &quot;country&quot;:&quot;China&quot;,</span><br><span class="line">        &quot;city&quot;:&quot;BJ&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user2 = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;BDYJY&quot;,</span><br><span class="line">    &quot;age&quot;:18,</span><br><span class="line">    &quot;hobbies&quot;:[&quot;music&quot;,&quot;read&quot;],</span><br><span class="line">    &quot;addr&quot;:&#123;</span><br><span class="line">        &quot;country&quot;:&quot;China&quot;,</span><br><span class="line">        &quot;city&quot;:&quot;BJ&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">user3 = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;CJK&quot;,</span><br><span class="line">    &quot;age&quot;:18,</span><br><span class="line">    &quot;hobbies&quot;:[&quot;music&quot;,&quot;read&quot;],</span><br><span class="line">    &quot;addr&quot;:&#123;</span><br><span class="line">        &quot;country&quot;:&quot;China&quot;,</span><br><span class="line">        &quot;city&quot;:&quot;BJ&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">db.user.save([user1,user2,user3])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><p>通过<code>update</code>系列函数或则<code>save</code>函数可以更新集合中的文档。我们来详细看下<code>update</code>函数的使用，上面已经讲过<code>save</code>函数<br><code>update()</code>函数用于更新已存在的文档。语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.update(query,update,options)</span><br></pre></td></tr></table></figure><ul><li><code>query</code>:update的查询条件，类似SQL update 语法中的where部分</li><li><code>update</code>:update的对象和一些更新的操作符(如$,$inc,$unset,$push,$pop,$pull,$pullAll,$rename)等，也可以理解为SQL update语法中的set部分。</li><li><code>upsert</code>:可选，如果不存在update的文档，是否插入该文档。true为插入，默认是false，不插入。</li><li><code>multi</code>:可选，是否批量更新。true表示按条件查询出来的多条记录全部更新，false只更新找到的第一条记录，默认是false。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#示例代码</span><br><span class="line">user = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;wangwu&quot;,</span><br><span class="line">    &quot;age&quot;:18,</span><br><span class="line">    &quot;hobbies&quot;:[&quot;music&quot;,&quot;read&quot;],</span><br><span class="line">    &quot;addr&quot;:&#123;</span><br><span class="line">        &quot;country&quot;:&quot;China&quot;,</span><br><span class="line">        &quot;city&quot;:&quot;BJ&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 修改单条--全文档更新操作</span><br><span class="line">db.user.updateOne(&#123;&quot;name&quot;:&quot;LiSA&quot;&#125;,user)</span><br><span class="line"># 查找到的匹配数据如果是多条，只会修改第一条--全文档更新操作</span><br><span class="line">db.user.update(&#123;&quot;name&quot;:&quot;LiSA&quot;&#125;,user)#修改单条等价于 updateOne()</span><br><span class="line">#查找到的匹配数据如果是多条，修改所有匹配到的记录</span><br><span class="line">db.user.update(&#123;&quot;name&quot;:&quot;LiSA&quot;&#125;,&#123;&quot;$set&quot;:user&#125;,&#123;multi:true&#125;)#修改多条</span><br><span class="line">db.user.updateMany(&#123;&quot;name&quot;:&quot;张三1231231&quot;&#125;,&#123;&quot;$set&quot;:user&#125;)#修改多条</span><br><span class="line"></span><br><span class="line">#修改单条</span><br></pre></td></tr></table></figure><h4 id="更新操作符"><a href="#更新操作符" class="headerlink" title="更新操作符"></a>更新操作符</h4><ul><li><code>$set</code>操作符（需要记忆）<br><code>$set</code>操作符：用于指定一个键并更新键值，若键不存在并创建。<strong>只能修改第一个document</strong><br>语法格式：db.COLLECTION_NAMAE.update({查询条件},{更新操作符:{更新内容}})<br><code>$set</code>的作用总结：<ol><li>只修改特定的Field，解决update默认修改整个document情况<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.c1.update(&#123;name:&quot;张三&quot;&#125;,&#123;$set:&#123;name:&quot;王五&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure></li><li>默认只修改符合条件第一个document，如果需要全部修改，添加更新参数multi:true<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.c1.update(&#123;name:&quot;张三&quot;&#125;,&#123;$set:&#123;name:&quot;王五&quot;&#125;&#125;,&#123;mutli:true&#125;)</span><br></pre></td></tr></table></figure></li><li>如果Field不存在，可以新建一个Field<br>db.c1.update({name:”张三”},{$set:{sex”男”}})</li></ol></li><li><code>$inc</code>操作符：可以对文档的某个值为数字型(<strong>只能为满足要求的数字</strong>)的键及增删操作。如果给定负数表示减少。<br>  把王五的年龄减少5岁  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.c1.update(&#123;name:&quot;王五&quot;&#125;,&#123;$inc:&#123;age:-5&#125;&#125;)</span><br></pre></td></tr></table></figure></li><li><code>$unset</code>操作符：主要是用来删除键。让键的值为空。在编写命令时$unset理field取任意值，无论给定什么值都表示删除。</li><li><code>$push</code>操作符：向文档的某个数组类型的键添加一个数组元素，不过滤重复的数据。添加时键存在，要求键值类型必须是数组；键不存在，则创建数组类型的键。</li><li><code>$pop</code>操作符：删除数据元素。可取只能是1或-1。1表示尾部删除，-1表示头部删除</li><li><code>$pull</code>操作符：从数组中删除满足条件的元素，只要满足条件都删除</li><li><code>$pullAll</code>操作符：可以设置多个条件</li><li><code>$rename</code>操作符：对键盘进行重新命名。任何类型的键都能重命名。</li></ul><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>MongoDB remove()函数是用来移除集合中的数据，其语法格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.user.remove(&lt;query&gt;,&#123;justOne:&lt;boolean&gt;&#125;)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>query：(可选)删除的文档的条件。</li><li>justOne:(可选)如果设为true，则只删除一个文档，False删除所有匹配的数据<br>等价于<code>db.user.deleteOne(&lt;query&gt;)</code>:删除符合条件的第一个文档<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.user.remove(&#123;&quot;name&quot;:&quot;lisa&quot;&#125;,&#123;justOne:true&#125;)</span><br><span class="line">db.user.deleteOne(&#123;&quot;name&quot;:&quot;lisa&quot;&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>删除所有数据命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.user.remove(&#123;&#125;)</span><br><span class="line">#等价于</span><br><span class="line">db.user.deleteMany(&#123;&#125;)#等于是清空该集合(表)</span><br></pre></td></tr></table></figure><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><h4 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h4><p>MongoDB 查询数据的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.user.find()#等同于db.user.find(&#123;&#125;)</span><br><span class="line">#去重</span><br><span class="line">db.user.distinct(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure><p>find()方法以非结构化的方式来显示所有文档<br>如果你需要以易读的方式来读取数据，可以使用pretty()方法，语法格式如下：<br>格式化-》返回的内容易读</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.user.find().pretty()</span><br></pre></td></tr></table></figure><p>pretty()方法以格式化的方式来显示所有文档</p><h4 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h4><p><strong>注意：在MongoDB中，用到方法逗得用$符号开头</strong><br>=，!=(‘$ne’)，&gt;(‘$gt’)，&lt;(‘$lt’)，&gt;=(‘$gte’)，&lt;=(‘$lte’)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1. select * from user where id = 3</span><br><span class="line">db.user.find(&#123;&#x27;_id&#x27;:3&#125;)</span><br><span class="line"></span><br><span class="line">#2. select * from user where id != 3</span><br><span class="line">db.user.find(&#123;&#x27;_id&#x27;:&#123;&quot;$ne&quot;:3&#125;&#125;)</span><br><span class="line"></span><br><span class="line">#3. select * from user where id &gt; 3</span><br><span class="line">db.user.find(&#123;&#x27;_id&#x27;:&#123;&quot;$gt&quot;:3&#125;&#125;)</span><br><span class="line"></span><br><span class="line">#4. select * from user where age &lt; 3</span><br><span class="line">db.user.find(&#123;&#x27;age&#x27;:&#123;&quot;$lt&quot;:3&#125;&#125;)</span><br><span class="line"></span><br><span class="line">#5. select * from user where id &gt;= 3</span><br><span class="line">db.user.find(&#123;&#x27;_id&#x27;:&#123;&quot;$gte&quot;:3&#125;&#125;)</span><br><span class="line"></span><br><span class="line">#6. select * from user where id &lt;= 3</span><br><span class="line">db.user.find(&#123;&#x27;_id&#x27;:&#123;&quot;$lte&quot;:3&#125;&#125;)</span><br></pre></td></tr></table></figure><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>MongoDB 中字典内用逗号分隔多个条件是and关系，或则直接用$and,$or,$not(与或非)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#逻辑运算：$and,$or,$not</span><br><span class="line">#1. select * from user where id &gt;=3 and id &lt;=4;</span><br><span class="line">db.user.find(&#123;_id:&#123;$gte:3,$lte:4&#125;&#125;)</span><br><span class="line"></span><br><span class="line">#2. select * from user where id &gt;=3 and id &lt;=4 and age &gt;=4;</span><br><span class="line">db.user.find(&#123;</span><br><span class="line">    &quot;_id&quot;:&#123;$gte:3,$lte:4&#125;,</span><br><span class="line">    &quot;age&quot;:&#123;$gte:4&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">db.user.find(&#123;</span><br><span class="line">    &quot;$and&quot;:[</span><br><span class="line">        &#123;&quot;_id&quot;:&#123;$gte:3,$lte:4&#125;&#125;,</span><br><span class="line">        &#123;&quot;age&quot;:&#123;$gte:4&#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">#3. select * from user where id &gt;=0 and id&lt;=1 or name =&quot;LiSA&quot;;</span><br><span class="line">db.user.find(&#123;</span><br><span class="line">    &quot;$or&quot;:[</span><br><span class="line">        &#123;&quot;_id&quot;:&#123;$gte:0,$lte:1&#125;&#125;,</span><br><span class="line">        &#123;&quot;name&quot;:&quot;LiSA&quot;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">db.user.find(&#123;</span><br><span class="line">    &quot;$or&quot;:[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;and&quot;:[</span><br><span class="line">                &#123;_id:&#123;$gte:0&#125;&#125;,</span><br><span class="line">                &#123;_id:&#123;$lte:1&#125;&#125;</span><br><span class="line">                ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;&quot;name&quot;:&quot;LiSA&quot;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">#4. select * from user where id%2=1;</span><br><span class="line">db.user.find(&#123;&quot;_id&quot;:&#123;$mod:[2,1]&#125;&#125;)</span><br><span class="line"></span><br><span class="line">#上一条取反</span><br><span class="line">db.user.find(&#123;</span><br><span class="line">    &quot;_id&quot;:&#123;&quot;$not&quot;:&#123;&quot;$mod&quot;:[2,1]&#125;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="成员运算"><a href="#成员运算" class="headerlink" title="成员运算"></a>成员运算</h4><p>成员运算无非in 和 not in，MongoDB中形式为<code>$in</code>、<code>$nin</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1. select * from user where age in(1,2,3)</span><br><span class="line">db.user.find(&#123;&quot;age&quot;:&#123;$in:[1,2,3]&#125;&#125;)</span><br><span class="line"></span><br><span class="line">#2. select * from user where name not in (&quot;zhangsan&quot;,&quot;lisa&quot;)</span><br><span class="line">db.user.find(&#123;&quot;name&quot;:&#123;$nin:[&quot;zhangsan&quot;,&quot;lisa&quot;]&#125;&#125;)</span><br></pre></td></tr></table></figure><h4 id="type操作符"><a href="#type操作符" class="headerlink" title="$type操作符"></a>$type操作符</h4><p><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220317222742.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询name是字符串类型的数据</span><br><span class="line">db.user.find(&#123;name:&#123;$type:2&#125;&#125;).pretty()</span><br></pre></td></tr></table></figure><h4 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1. select * from user where name regexp &#x27;^z.*?(u|i)$&#x27;;</span><br><span class="line">#匹配规则：z开头、n或u结尾，不区分大小写</span><br><span class="line">db.user.find(&#123;&#x27;name&#x27;:/^z.*?(u|i)$/i&#125;)</span><br></pre></td></tr></table></figure><h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p>MongoDB投影意思是只选择必要的数据而不是选择一整个文档的数据<br>在MongoDB中，当执行find()方法，那么它会显示一个文档所有字段。要限制这一点，需要设置字段列表值1或0</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1. select name,age from user where id =3 ;</span><br><span class="line">db.user.find(&#123;&#x27;_id&#x27;:3&#125;,&#123;&#x27;_id&#x27;:0,&#x27;name&#x27;:1,&#x27;age&#x27;:1&#125;)</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询数组相关</span><br><span class="line">#查hobbies中有dancing的人</span><br><span class="line">db.user.find(&#123;</span><br><span class="line">    &quot;hobbies&quot;:&quot;dancing&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">#查看既有dancing爱好又有tea爱好的人</span><br><span class="line">db.user.find(&#123;</span><br><span class="line">    &quot;hobbies&quot;:&#123;&quot;$all&quot;:[&quot;dancing&quot;,tea]&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">#查看索引第2个爱好为dancing的人(索引从0开始计算)</span><br><span class="line">db.user.find(&#123;</span><br><span class="line">    &quot;hobbies.2&quot;:&quot;dancing&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">#查看所有人的第1个到第3个爱好，第一个&#123;&#125;表示查询条件为所有，第二个是显示条件（左闭右开）</span><br><span class="line">db.user.find(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;_id&quot;:0,</span><br><span class="line">        &quot;name&quot;:0,</span><br><span class="line">        &quot;age&quot;:0,</span><br><span class="line">        &quot;addr&quot;:0,</span><br><span class="line">        &quot;hobbies&quot;:&#123;&quot;$slice&quot;:[0,2]&#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#查看所有人最后两个爱好，第一个&#123;&#125;表示查询条件为所有，第二个为显示条件</span><br><span class="line">db.user.find(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;_id&quot;:0,</span><br><span class="line">        &quot;name&quot;:0,</span><br><span class="line">        &quot;age&quot;:0,</span><br><span class="line">        &quot;addr&quot;:0,</span><br><span class="line">        &quot;hobbies&quot;:&#123;&quot;$slice&quot;:-2&#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#查询子文档有&quot;country&quot;:&quot;China&quot;的人</span><br><span class="line">db.user.find(&#123;</span><br><span class="line">    &quot;addr.country&quot;:&quot;China&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>在MongoDB中使用sort()方法对数据进行排序，sort()可以通过参数指定排序的字段，并且使用1和-1来指定排序的方式，其中1为升序排列，而-1是用于降序排列</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#按姓名正序</span><br><span class="line">db.user.find().sort(&#123;&quot;name&quot;:1&#125;)</span><br><span class="line">#按年龄倒序，按id正序</span><br><span class="line">db.user.find().sort(&#123;&quot;age&quot;:1,&quot;_id&quot;:1&#125;)</span><br></pre></td></tr></table></figure><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>limit表示取多少个document，skip代表跳过几个document<br>分页公式：db.user.find().skip((pageNum-1)*pageSize).limit(pageSize)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.user.find().limit(2).skip(0)#前2个</span><br><span class="line">db.user.find().limit(2).skip(2)#第三个和第四个</span><br><span class="line">db.user.find().limit(2).skip(4)#第五个和第六个</span><br></pre></td></tr></table></figure><h4 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询_id大于3的人数</span><br><span class="line">#方式一</span><br><span class="line">db.user.count(&#123;&#x27;_id&#x27;:&#123;$gt:3&#125;&#125;)</span><br><span class="line">#方式二</span><br><span class="line">db.user.find(&#123;&quot;_id&quot;:&#123;$gt:3&#125;&#125;).count()</span><br></pre></td></tr></table></figure><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>我们在查询时肯定会用到聚合，在MongoDB中聚合为aggregate，聚合函数主要用到<code>$match</code>,<code>$group</code>,<code>$avg</code>,<code>$project</code>,<code>$concat</code>,可以加<code>$match</code>也可以不加<code>$match</code><br><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220317230225.png"></p><h4 id="Aggregate语法"><a href="#Aggregate语法" class="headerlink" title="Aggregate语法"></a>Aggregate语法</h4><p><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220317230817.png"></p><h4 id="match和-group"><a href="#match和-group" class="headerlink" title="$match和$group"></a>$match和$group</h4><p>相当于sql语句的where和group by<br>{“$match”:{“字段”:”条件”}}，可以使用任何常用查询操作符$gt,$lt,$in等<br>{“$group”:{“_id”:分组字段，”新的字段名”:聚合操作符}}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;$match&quot;:&#123;&quot;字段&quot;:&quot;条件&quot;&#125;&#125;，可以使用任何常用查询操作符$gt,$lt,$in等</span><br><span class="line"></span><br><span class="line"># select * from db1.emp where post = &#x27;公务员&#x27;;</span><br><span class="line">db.emp.aggregate([&quot;$match&quot;:&#123;&quot;post&quot;:&quot;公务员&quot;&#125;])</span><br><span class="line"></span><br><span class="line"># select * from db1.emp where id &gt; 3 group by post;</span><br><span class="line">db.emp.aggregate([</span><br><span class="line">    &#123;&quot;$match&quot;:&#123;&quot;_id&quot;:&#123;&quot;$gt&quot;:3&#125;&#125;&#125;,</span><br><span class="line">    &#123;&quot;$group&quot;:&#123;&quot;_id&quot;:&quot;$post&quot;,&quot;avg_salary&quot;:&#123;&quot;$avg&quot;:&quot;$salary&quot;&#125;&#125;&#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"># select * from db1.emp where id &gt; 3 group by post having avg(salary) &gt;10000</span><br><span class="line">db.emp.aggregate([</span><br><span class="line">    &#123;&quot;$match&quot;:&#123;&quot;_id&quot;:&#123;&quot;$gt&quot;:3&#125;&#125;&#125;,</span><br><span class="line">    &#123;&quot;$group&quot;:&#123;&quot;_id&quot;:&quot;$post&quot;,&quot;avg_salary&quot;:&#123;&quot;$avg&quot;:&quot;$salary&quot;&#125;&#125;&#125;,</span><br><span class="line">    &#123;&quot;$match&quot;:&#123;&quot;avg_salary:&#123;&quot;$gt&quot;:10000&#125;&quot;&#125;&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220317232755.png"><br><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220317233007.png"><br><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220317233200.png"></p><h4 id="project"><a href="#project" class="headerlink" title="$project"></a>$project</h4><p><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220317233338.png"></p><h4 id="sort和-limit和-skip"><a href="#sort和-limit和-skip" class="headerlink" title="$sort和$limit和$skip"></a>$sort和$limit和$skip</h4><p><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220317233526.png"><br><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220317233715.png"></p><h4 id="sample"><a href="#sample" class="headerlink" title="$sample"></a>$sample</h4><p><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220317233837.png"></p><h4 id="concat和-substr和-toLower和-toUppper"><a href="#concat和-substr和-toLower和-toUppper" class="headerlink" title="$concat和$substr和$toLower和$toUppper"></a>$concat和$substr和$toLower和$toUppper</h4><p><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220317233958.png"><br><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220317234217.png"></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220317234348.png"></p><h3 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h3><p><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220317234437.png"></p><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220317234653.png"></p><h1 id="SpringDataMongoDB"><a href="#SpringDataMongoDB" class="headerlink" title="SpringDataMongoDB"></a>SpringDataMongoDB</h1><h2 id="创建一个SpringBoot的maven项目"><a href="#创建一个SpringBoot的maven项目" class="headerlink" title="创建一个SpringBoot的maven项目"></a>创建一个SpringBoot的maven项目</h2><h2 id="导入pom的依赖"><a href="#导入pom的依赖" class="headerlink" title="导入pom的依赖"></a>导入pom的依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="编写连接字符串"><a href="#编写连接字符串" class="headerlink" title="编写连接字符串"></a>编写连接字符串</h2><p>application.properties</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#application.properties的配置写法</span><br><span class="line">spring.data.mongodb.uri=mongodb://zzf:123456@hadoop105:27017/test?authSource=admin</span><br><span class="line"></span><br><span class="line">#application.yml的配置写法</span><br><span class="line">spring:</span><br><span class="line">  data:</span><br><span class="line">    mongodb:</span><br><span class="line">      host: hadoop105</span><br><span class="line">      username: &#x27;zzf&#x27;</span><br><span class="line">      password: &#x27;123456&#x27;</span><br><span class="line">      port: 27017</span><br><span class="line">      database: test</span><br><span class="line">      authentication-database: admin</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编写一个实体类"><a href="#编写一个实体类" class="headerlink" title="编写一个实体类"></a>编写一个实体类</h2><table><thead><tr><th align="left">注解</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">@Id</td><td align="left">用于标记id字段，没有标记此字段的实体也会自动生成id字段，但是我们无法通过实体来获取id。id建议使用ObjectId类型来创建。</td></tr><tr><td align="left">@Document</td><td align="left">用于标记此实体类是mongodb集合映射类。可以使用collection参数指定集合名称。特别需要注意的是如果实体类没有为任何字段创建索引将不会自动创建集合。</td></tr><tr><td align="left">@Indexed</td><td align="left">用于标记为某一字段创建索引。direction参数可以指定排序方向，升或降序。</td></tr><tr><td align="left">@CompoundIndex</td><td align="left">用于创建复合索引。def参数可以定义复合索引的字段及排序方向。</td></tr><tr><td align="left">@Transient</td><td align="left">被该注解标注的，将不会被录入到数据库中。只作为普通的javaBean属性。</td></tr><tr><td align="left">@PersistenceConstructor</td><td align="left">用于声明构造函数，作用是把从数据库取出的数据实例化为对象。</td></tr><tr><td align="left">@Field</td><td align="left">用于指定某一个字段映射到数据库中的名称。</td></tr><tr><td align="left">@DBRef</td><td align="left">用于指定与其他集合的级联关系，但是需要注意的是并不会自动创建级联集合。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Document(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编写一个dao接口继承MongoRepository-lt-实体类-主键类型-gt"><a href="#编写一个dao接口继承MongoRepository-lt-实体类-主键类型-gt" class="headerlink" title="编写一个dao接口继承MongoRepository&lt;实体类,主键类型&gt;"></a>编写一个dao接口继承MongoRepository&lt;实体类,主键类型&gt;</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">User</span>,<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><a href="https://gitee.com/dgut_zzf/spring-data-mongo-db.git">案例学习git下载</a></p><h1 id="SpringData规则"><a href="#SpringData规则" class="headerlink" title="SpringData规则"></a>SpringData规则</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommentRepository</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">Comment</span>,<span class="title">String</span> &gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Page&lt;Comment&gt; <span class="title">findByParentid</span><span class="params">(String parentid, Pageable pageable)</span></span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>想必大家在学习MongoDB会看到类似的接口，写着方法名，没有写相应实现类也没有对应xml就能实现调用。后来根据学习与探究发现底层是使用SpringData的规则应用，以下是学习记录。</p></blockquote><h2 id="方法命名规则查询"><a href="#方法命名规则查询" class="headerlink" title="方法命名规则查询"></a>方法命名规则查询</h2><blockquote><p>顾名思义，方法命名规则查询就是根据方法的名字，就能创建查询。只需要按照SpringData JPA提供的方法。<br>命名规则定义方法的名称，就可以完成查询工作。<br>SpringData JPA在程序执行的时候会根据方法名称进行解析，并自动生成查询语句进行查询.<br>按照SpringData JPA定义的规则，查询方法以findBy开头，涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性首字母需大写。框架在进行方法名解析时，会先把方法名多余的前缀截取掉，然后对剩下部分进行解析 。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Article&gt; <span class="title">findByTitle</span><span class="params">(String title)</span></span>;</span><br><span class="line"><span class="comment">//根据标题模糊查询</span></span><br><span class="line"><span class="function">List&lt;Article&gt; <span class="title">findByTitleLike</span><span class="params">(String title)</span></span>;</span><br><span class="line"><span class="comment">//根据标题和作者查询</span></span><br><span class="line"><span class="function">List&lt;Article&gt; <span class="title">findByTitleAndAuthor</span><span class="params">(String title, String author)</span></span>;</span><br><span class="line"><span class="comment">//根据ID范围查询</span></span><br><span class="line"><span class="function">List&lt;Article&gt; <span class="title">findByAidBetween</span><span class="params">(Integer starAid, Integer endAid)</span></span>;</span><br><span class="line"><span class="function">List&lt;Article&gt; <span class="title">findByAidLessThan</span><span class="params">(Integer endAid)</span></span>;</span><br><span class="line"><span class="function">List&lt;Article&gt; <span class="title">findByAidIn</span><span class="params">(List&lt;Integer&gt; aids)</span></span>;</span><br><span class="line"><span class="comment">//根据创建时间之后查询</span></span><br><span class="line"><span class="function">List&lt;Article&gt; <span class="title">findByCreateTimeAfter</span><span class="params">(Date createTime)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220406114352.png"><br><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220406114745.png"><br><img src="/img/mongoDB/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220406121625.png"></p><h2 id="定义查询方法"><a href="#定义查询方法" class="headerlink" title="定义查询方法"></a>定义查询方法</h2><p>存储库代理有两种从方法名称派生特定于 Store 的查询的方式：</p><ul><li>通过直接从方法名称派生查询。</li><li>通过使用手动定义的查询。<br>可用选项取决于实际 Store。但是，必须有一个策略来决定要创建的实际查询。下一节将介绍可用的选项。</li></ul><h2 id="查询查询策略"><a href="#查询查询策略" class="headerlink" title="查询查询策略"></a>查询查询策略</h2><p>以下策略可用于存储库基础结构来解决查询。使用 XML 配置，您可以通过query-lookup-strategy属性在名称空间中配置策略。对于 Java 配置，可以使用Enable${store}Repositories注解的queryLookupStrategy属性。某些数据存储可能不支持某些策略。</p><ul><li>CREATE尝试从查询方法名称构造特定于 Store 的查询。通用方法是从方法名称中删除一组给定的众所周知的前缀，然后解析该方法的其余部分。您可以在“ Query Creation”中阅读有关查询构造的更多信息。</li><li>USE_DECLARED_QUERY尝试查找已声明的查询，如果找不到则抛出异常。该查询可以通过某处的 Comments 定义，也可以通过其他方式声明。请查阅特定 Store 的文档以找到该 Store 的可用选项。如果存储库基础结构在引导时找不到该方法的声明查询，则它将失败。</li><li>CREATE_IF_NOT_FOUND(默认)组合了CREATE和USE_DECLARED_QUERY。它首先查找一个声明的查询，如果找不到声明的查询，它将创建一个基于名称的自定义方法查询。这是默认的查找策略，因此，如果未显式配置任何内容，则使用该策略。它允许通过方法名称快速定义查询，还可以通过根据需要引入已声明的查询来自定义调整这些查询。</li></ul><h2 id="查询创建"><a href="#查询创建" class="headerlink" title="查询创建"></a>查询创建</h2><p>内置在 Spring Data 存储库基础结构中的查询构建器机制对于在存储库实体上构建约束查询很有用。该机制从方法中剥离前缀find…By，read…By，query…By，count…By和get…By，并开始解析其余部分。 Introduction 子句可以包含其他表达式，例如Distinct，以在要创建的查询上设置不同的标志。但是，第一个By充当分隔符，以指示实际标准的开始。在最基本的级别上，您可以定义实体属性的条件，并将它们与And和Or串联。以下示例显示了如何创建许多查询：</p><p>例子 13.从方法名查询创建</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByEmailAddressAndLastname</span><span class="params">(EmailAddress emailAddress, String lastname)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Enables the distinct flag for the query</span></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findDistinctPeopleByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span></span>;</span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findPeopleDistinctByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Enabling ignoring case for an individual property</span></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameIgnoreCase</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">  <span class="comment">// Enabling ignoring case for all suitable properties</span></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameAndFirstnameAllIgnoreCase</span><span class="params">(String lastname, String firstname)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Enabling static ORDER BY for a query</span></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameOrderByFirstnameAsc</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameOrderByFirstnameDesc</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析该方法的实际结果取决于您为其创建查询的持久性存储。但是，需要注意一些一般事项：</p><p>表达式通常是属性遍历，并带有可串联的运算符。您可以将属性表达式与AND和OR结合使用。您还将获得对属性表达式的支持，例如Between，LessThan，GreaterThan和Like。支持的运算符可能因数据存储而异，因此请参考参考文档的相应部分。<br>方法解析器支持为单个属性(例如findByLastnameIgnoreCase(…))或支持忽略大小写的类型的所有属性(通常为String instance_，例如findByLastnameAndFirstnameAllIgnoreCase(…))设置IgnoreCase标志。是否支持忽略大小写可能因 Store 而异，因此请参考参考文档中有关 Store 特定查询方法的相关部分。<br>您可以通过将OrderBy子句附加到引用属性的查询方法并提供排序方向(Asc或Desc)来应用静态排序。要创建支持动态排序的查询方法，请参阅“ <a href="https://www.docs4dev.com/docs/zh/spring-data-jpa/1.11.18.RELEASE/reference/all.html#repositories.special-parameters">特殊参数处理</a>”。</p><h2 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h2><p>如上例所示，属性表达式只能引用被管实体的直接属性。在查询创建时，您已经确保已解析的属性是托管域类的属性。但是，您也可以通过遍历嵌套属性来定义约束。考虑以下方法签名：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Person&gt; <span class="title">findByAddressZipCode</span><span class="params">(ZipCode zipCode)</span></span>;</span><br></pre></td></tr></table></figure><p>假设Person具有Address和ZipCode。在这种情况下，该方法将创建属性遍历x.address.zipCode。解析算法首先将整个部分(AddressZipCode)解释为属性，然后在域类中检查具有该名称的属性(未大写)。如果算法成功，它将使用该属性。如果不是，该算法将驼峰案例部分的源从右侧分为头和尾，并尝试找到相应的属性，在我们的示例中为AddressZip和Code。如果该算法找到了具有该头部的属性，则将其取为尾部，并 continue 从此处开始构建树，以刚才描述的方式将尾部向上拆分。如果第一个分割不匹配，则算法将分割点移到左侧(Address，ZipCode)并 continue。</p><p>尽管这在大多数情况下应该可行，但算法可能会选择错误的属性。假设Person类也具有addressZip属性。该算法将在第一轮拆分中已经匹配，选择错误的属性，然后失败(因为addressZip的类型可能没有code属性)。</p><p>要解决这种歧义，您可以在方法名称中使用_来手动定义遍历点。因此，我们的方法名称如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Person&gt; <span class="title">findByAddress_ZipCode</span><span class="params">(ZipCode zipCode)</span></span>;</span><br></pre></td></tr></table></figure><p>因为我们将下划线字符视为保留字符，所以我们强烈建议您遵循以下标准 Java 命名约定(即，在属性名称中不使用下划线，而使用驼峰大小写)。</p><h2 id="特殊参数处理"><a href="#特殊参数处理" class="headerlink" title="特殊参数处理"></a>特殊参数处理</h2><p>要处理查询中的参数，请定义方法参数，如前面的示例所示。除此之外，基础架构还可以识别某些特定类型(例如Pageable和Sort)，以将分页和排序动态应用于您的查询。下面的示例演示了这些功能：</p><p>例子 14.在查询方法中使用Pageable，Slice和Sort</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Page&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">Slice&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Sort sort)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure><p>第一种方法使您可以将org.springframework.data.domain.Pageable实例传递给查询方法，以将分页动态添加到静态定义的查询中。 Page知道可用元素和页面的总数。它是通过基础结构触发计数查询来计算总数来实现的。由于这可能很昂贵(取决于使用的 Store)，因此您可以返回Slice。 Slice仅知道下一个Slice是否可用，当遍历较大的结果集时可能就足够了。</p><p>排序选项也通过Pageable实例处理。如果只需要排序，则将org.springframework.data.domain.Sort参数添加到您的方法中。如您所见，返回List也是可能的。在这种情况下，不会创建构建实际Page实例所需的其他元数据(这反过来，这意味着不会发出本来必要的其他计数查询)。而是，它将查询限制为仅查找给定范围的实体。</p><p>要查明整个查询可获得多少页，您必须触发另一个计数查询。默认情况下，此查询源自您实际触发的查询。</p><h2 id="限制查询结果"><a href="#限制查询结果" class="headerlink" title="限制查询结果"></a>限制查询结果</h2><p>可以使用first或top关键字来限制查询方法的结果，这些关键字可以互换使用。可以将一个可选的数值附加到top或first以指定要返回的最大结果大小。如果省略该数字，则假定结果大小为 1.以下示例显示了如何限制查询大小：</p><p>例子 15.用Top和First限制查询的结果大小</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">findFirstByOrderByLastnameAsc</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">User <span class="title">findTopByOrderByAgeDesc</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">Page&lt;User&gt; <span class="title">queryFirst10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">Slice&lt;User&gt; <span class="title">findTop3ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findFirst10ByLastname</span><span class="params">(String lastname, Sort sort)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findTop10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure><p>限制表达式还支持Distinct关键字。此外，对于将结果集限制为一个实例的查询，支持使用Optional关键字将结果包装到其中。</p><p>如果将分页或切片应用于限制查询分页(以及对可用页面数的计算)，则会在限制结果内应用分页或切片。</p><p>通过使用Sort参数来限制结果与动态排序的组合，可以让您表达对最小的“ K”元素和对“ K”的最大元素的查询方法。</p><h2 id="流查询结果"><a href="#流查询结果" class="headerlink" title="流查询结果"></a>流查询结果</h2><p>通过使用 Java 8 Stream<T>作为返回类型，可以递增地处理查询方法的结果。而不是将查询结果包装在Stream数据存储区中，而是使用特定于方法的方法来执行流传输，如以下示例所示：</p><p>例子 16.用 Java 8 Stream<T>流式查询的结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;select u from User u&quot;)</span></span><br><span class="line"><span class="function">Stream&lt;User&gt; <span class="title">findAllByCustomQueryAndStream</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">Stream&lt;User&gt; <span class="title">readAllByFirstnameNotNull</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Query(&quot;select u from User u&quot;)</span></span><br><span class="line"><span class="function">Stream&lt;User&gt; <span class="title">streamAllPaged</span><span class="params">(Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure><p>Stream可能包装了特定于底层数据存储的资源，因此在使用后必须将其关闭。您可以使用close()方法或使用 Java 7 try-with-resources块来手动关闭Stream，如以下示例所示：</p><p>例子 17.使用Stream<T>导致 try-with-resources 块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Stream&lt;User&gt; stream = repository.findAllByCustomQueryAndStream()) &#123;</span><br><span class="line">  stream.forEach(…);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步查询结果"><a href="#异步查询结果" class="headerlink" title="异步查询结果"></a>异步查询结果</h2><p>可以使用Spring 的异步方法执行能力异步运行存储库查询。这意味着该方法在调用时立即返回，而实际查询执行发生在已提交给 Spring TaskExecutor的任务中。异步查询执行与反应式查询执行不同，因此不应混为一谈。有关响应式支持的更多详细信息，请参阅 Store 特定的文档。以下示例显示了许多异步查询：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Async</span><br><span class="line">Future&lt;User&gt; findByFirstname(String firstname);               (1)</span><br><span class="line"> </span><br><span class="line">@Async</span><br><span class="line">CompletableFuture&lt;User&gt; findOneByFirstname(String firstname); (2)</span><br><span class="line"> </span><br><span class="line">@Async</span><br><span class="line">ListenableFuture&lt;User&gt; findOneByLastname(String lastname);    (3)</span><br></pre></td></tr></table></figure><p>(1) 使用java.util.concurrent.Future作为返回类型。<br>(2) 使用 Java 8 java.util.concurrent.CompletableFuture作为返回类型。<br>(3) 使用org.springframework.util.concurrent.ListenableFuture作为返回类型。</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark学习--Scala</title>
      <link href="/2021/11/24/Spark%E5%AD%A6%E4%B9%A0-Scala/"/>
      <url>/2021/11/24/Spark%E5%AD%A6%E4%B9%A0-Scala/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/c_1322208528018984960">学习资料</a><br><a href="https://blog.csdn.net/u010376788/article/details/47703619">有关数组知识点</a><br><a href="https://blog.csdn.net/qq_38314823/article/details/81038200">有关”_”的学习资料</a><br><a href="http://dblab.xmu.edu.cn/blog/966-2/">reduce操作</a><br><a href="https://www.cnblogs.com/pursue339/p/10619662.html">Nil用法</a><br><a href="https://blog.csdn.net/liu16659/article/details/80427381">Scala中的mkString</a><br><a href="https://blog.csdn.net/u013560925/article/details/79951885/">Scala中map小括号与大括号</a><br><a href="https://www.cnblogs.com/yumengfei/p/12030441.html">Scala中sortBy和Spark中sortBy区别</a><br><a href="https://blog.csdn.net/maybe_fly/article/details/77979867">Scala中sortBy方法</a><br><a href="https://blog.51cto.com/xingej/1963582">每天学一点Scala之take、takeRight、takeWhile与filter</a></p><p><a href="https://www.yiibai.com/sqlserver/sql-server-rank-function.html">sql中的排序开窗操作</a></p>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive数据上传</title>
      <link href="/2021/11/23/Hive%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/"/>
      <url>/2021/11/23/Hive%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/chy2z/article/details/80993272?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link">学习资料</a></p>]]></content>
      
      
      <categories>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python升级</title>
      <link href="/2021/11/22/Python%E5%8D%87%E7%BA%A7/"/>
      <url>/2021/11/22/Python%E5%8D%87%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/L_15156024189/article/details/84831045">学习资料</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos安装python-chardet</title>
      <link href="/2021/11/22/Centos%E5%AE%89%E8%A3%85python-chardet/"/>
      <url>/2021/11/22/Centos%E5%AE%89%E8%A3%85python-chardet/</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -O chardet-3.0.4.tar.gz https://github.com/chardet/chardet/archive/3.0.4.tar.gz</span><br><span class="line">tar -zxf chardet-3.0.4.tar.gz</span><br><span class="line">cd chardet-3.0.4 </span><br><span class="line">python setup.py install </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos6可用yum源【2021.11.22】</title>
      <link href="/2021/11/22/Centos6%E5%8F%AF%E7%94%A8yum%E6%BA%90%E3%80%902021-11-22%E3%80%91/"/>
      <url>/2021/11/22/Centos6%E5%8F%AF%E7%94%A8yum%E6%BA%90%E3%80%902021-11-22%E3%80%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言，这是经博主测试，于2021.11.22还仍然对Centos6可用的yum源【用的时候，记得改成自己的centos版本】</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[base]</span><br><span class="line">name=CentOS-6.10 - Base - mirrors.aliyun.com</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=http://mirrors.aliyun.com/centos-vault/6.10/os/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">released updates</span> </span><br><span class="line">[updates]</span><br><span class="line">name=CentOS-6.10 - Updates - mirrors.aliyun.com</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=http://mirrors.aliyun.com/centos-vault/6.10/updates/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">additional packages that may be useful</span></span><br><span class="line">[extras]</span><br><span class="line">name=CentOS-6.10 - Extras - mirrors.aliyun.com</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=http://mirrors.aliyun.com/centos-vault/6.10/extras/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">additional packages that extend functionality of existing packages</span></span><br><span class="line">[centosplus]</span><br><span class="line">name=CentOS-6.10 - Plus - mirrors.aliyun.com</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=http://mirrors.aliyun.com/centos-vault/6.10/centosplus/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">contrib - packages by Centos Users</span></span><br><span class="line">[contrib]</span><br><span class="line">name=CentOS-6.10 - Contrib - mirrors.aliyun.com</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=http://mirrors.aliyun.com/centos-vault/6.10/contrib/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python知识累积</title>
      <link href="/2021/11/12/Python%E7%9F%A5%E8%AF%86%E7%B4%AF%E7%A7%AF/"/>
      <url>/2021/11/12/Python%E7%9F%A5%E8%AF%86%E7%B4%AF%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="python-random-sample-的用法"><a href="#python-random-sample-的用法" class="headerlink" title="python:random.sample()的用法"></a>python:random.sample()的用法</h2><p>写脚本过程中用到了需要随机一段字符串的操作，查了一下资料，对于random.sample的用法，多用于截取列表的指定长度的随机数，但是不会改变列表本身的排序：</p><p>list = [0,1,2,3,4]<br>rs = random.sample(list, 2)<br>print(rs)<br>print(list)</p><p>》》》[2, 4] #此数组随着不同的执行，里面的元素随机，但都是两个<br>》》》[0, 1, 2, 3, 4]</p><h2 id="python路径拼接os-path-join-函数的用法"><a href="#python路径拼接os-path-join-函数的用法" class="headerlink" title="python路径拼接os.path.join()函数的用法"></a>python路径拼接os.path.join()函数的用法</h2><p>os.path.join()函数：连接两个或更多的路径名组件</p><pre><code>                     1.如果各组件名首字母不包含’/’，则函数会自动加上</code></pre><p>　　　　　　　　　2.如果有一个组件是一个绝对路径，则在它之前的所有组件均会被舍弃</p><p>　　　　　　　　　3.如果最后一个组件为空，则生成的路径以一个’/’分隔符结尾</p><p>Demo1<br>import os</p><p>Path1 = ‘home’<br>Path2 = ‘develop’<br>Path3 = ‘code’</p><p>Path10 = Path1 + Path2 + Path3<br>Path20 = os.path.join(Path1,Path2,Path3)<br>print (‘Path10 = ‘,Path10)<br>print (‘Path20 = ‘,Path20)</p><p>输出</p><p>Path10 = homedevelopcode<br>Path20 = home\develop\code</p><hr><p>Demo2</p><p>import os</p><p>Path1 = ‘/home’<br>Path2 = ‘develop’<br>Path3 = ‘code’</p><p>Path10 = Path1 + Path2 + Path3<br>Path20 = os.path.join(Path1,Path2,Path3)<br>print (‘Path10 = ‘,Path10)<br>print (‘Path20 = ‘,Path20)<br>输出</p><p>Path10 = /homedevelopcode<br>Path20 = /home\develop\code</p><hr><p>Demo3<br>import os</p><p>Path1 = ‘home’<br>Path2 = ‘/develop’<br>Path3 = ‘code’</p><p>Path10 = Path1 + Path2 + Path3<br>Path20 = os.path.join(Path1,Path2,Path3)<br>print (‘Path10 = ‘,Path10)<br>print (‘Path20 = ‘,Path20) </p><p>输出</p><p>Path10 = home/developcode<br>Path20 = /develop\code</p><hr><p>Demo4<br>import os</p><p>Path1 = ‘home’<br>Path2 = ‘develop’<br>Path3 = ‘/code’</p><p>Path10 = Path1 + Path2 + Path3<br>Path20 = os.path.join(Path1,Path2,Path3)<br>print (‘Path10 = ‘,Path10)<br>print (‘Path20 = ‘,Path20 )</p><p>输出</p><p>Path10 = homedevelop/code<br>Path20 = /code</p><h2 id="Python-isinstance-函数"><a href="#Python-isinstance-函数" class="headerlink" title="Python isinstance() 函数"></a>Python isinstance() 函数</h2><p><a href="https://www.runoob.com/python/python-func-isinstance.html">学习资料</a></p><h2 id="Python中json-dump-和-json-reload"><a href="#Python中json-dump-和-json-reload" class="headerlink" title="Python中json.dump() 和 json.reload()"></a>Python中json.dump() 和 json.reload()</h2><p><a href="https://www.runoob.com/python/python-json.html">学习资料</a></p><h2 id="Python-异常处理"><a href="#Python-异常处理" class="headerlink" title="Python 异常处理"></a>Python 异常处理</h2><p><a href="https://www.runoob.com/python/python-exceptions.html">学习资料</a></p><h2 id="Python-文件-IO"><a href="#Python-文件-IO" class="headerlink" title="Python 文件 IO"></a>Python 文件 IO</h2><p><a href="https://www.runoob.com/python3/python3-file-io.html">学习资料</a><br>Python引入了with语句来自动帮我们调用close()方法<br><a href="https://www.cnblogs.com/dingjiaoyang/p/11004065.html">参数详情</a></p><h2 id="Python-os-path-模块"><a href="#Python-os-path-模块" class="headerlink" title="Python os.path() 模块"></a>Python os.path() 模块</h2><p><a href="https://www.runoob.com/python/python-os-path.html">学习资料</a></p><h2 id="Python-正则表达式re-findall用法"><a href="#Python-正则表达式re-findall用法" class="headerlink" title="Python 正则表达式re.findall用法"></a>Python 正则表达式re.findall用法</h2><p><a href="https://www.cnblogs.com/xieshengsen/p/6727064.html">学习资料</a><br><a href="https://www.runoob.com/regexp/regexp-syntax.html">正则表达式</a></p><h2 id="Python-staticmethod-函数-静态方法"><a href="#Python-staticmethod-函数-静态方法" class="headerlink" title="Python staticmethod() 函数 [静态方法]"></a>Python staticmethod() 函数 [静态方法]</h2><p><a href="https://www.runoob.com/python/python-func-staticmethod.html">学习资料</a></p><h2 id="Python-line-strip-去掉每行头尾空白"><a href="#Python-line-strip-去掉每行头尾空白" class="headerlink" title="Python line.strip()  去掉每行头尾空白"></a>Python line.strip()  去掉每行头尾空白</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">fo = <span class="built_in">open</span>(<span class="string">&quot;runoob.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;文件名为: &quot;</span>, fo.name)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fo.readlines():                          <span class="comment">#依次读取每行  </span></span><br><span class="line">    line = line.strip()                             <span class="comment">#去掉每行头尾空白  </span></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;读取的数据为: %s&quot;</span> % (line))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure><h2 id="argparse-—-命令行选项、参数和子命令解析器"><a href="#argparse-—-命令行选项、参数和子命令解析器" class="headerlink" title="argparse — 命令行选项、参数和子命令解析器"></a>argparse — 命令行选项、参数和子命令解析器</h2><p><a href="https://docs.python.org/zh-cn/3/howto/argparse.html">学习资料</a><br><a href="https://blog.csdn.net/qq_34243930/article/details/106517985">参数详情</a></p><h2 id="Python-字典-Dictionary-update-方法"><a href="#Python-字典-Dictionary-update-方法" class="headerlink" title="Python 字典(Dictionary) update()方法"></a>Python 字典(Dictionary) update()方法</h2><p><a href="https://www.runoob.com/python/att-dictionary-update.html">学习资料</a></p><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><p><a href="https://www.cnblogs.com/liujiaxin2018/p/14446235.html">学习资料</a></p><h2 id="Python库-Faker【只支持Python3-4以上的版本】"><a href="#Python库-Faker【只支持Python3-4以上的版本】" class="headerlink" title="Python库 Faker【只支持Python3.4以上的版本】"></a>Python库 Faker【只支持Python3.4以上的版本】</h2><p><a href="https://zhuanlan.zhihu.com/p/87203290">学习资料</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中*args，**args的区别</title>
      <link href="/2021/11/12/python%E4%B8%AD-args%EF%BC%8C-args%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/11/12/python%E4%B8%AD-args%EF%BC%8C-args%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="python中-args，-args的区别"><a href="#python中-args，-args的区别" class="headerlink" title="python中*args，**args的区别"></a>python中*args，**args的区别</h1><p><a href="https://blog.csdn.net/devcy/article/details/89283523">学习资料</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>panads学习</title>
      <link href="/2021/11/12/panads%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/11/12/panads%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="pandas学习"><a href="#pandas学习" class="headerlink" title="pandas学习"></a>pandas学习</h1><p><a href="https://www.runoob.com/pandas/pandas-tutorial.html">学习资料</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> panads </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL知识点-知识遗漏</title>
      <link href="/2021/11/08/MYSQL%E7%9F%A5%E8%AF%86%E7%82%B9-%E7%9F%A5%E8%AF%86%E9%81%97%E6%BC%8F/"/>
      <url>/2021/11/08/MYSQL%E7%9F%A5%E8%AF%86%E7%82%B9-%E7%9F%A5%E8%AF%86%E9%81%97%E6%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="本章主要记录项目学习中的MySQL知识点遗漏"><a href="#本章主要记录项目学习中的MySQL知识点遗漏" class="headerlink" title="本章主要记录项目学习中的MySQL知识点遗漏"></a>本章主要记录项目学习中的MySQL知识点遗漏</h1><h2 id="INTERVAL关键字"><a href="#INTERVAL关键字" class="headerlink" title="INTERVAL关键字"></a>INTERVAL关键字</h2><p>INTERVAL关键字可以用于计算时间间隔，可以有以下用法。</p><p><a href="https://blog.csdn.net/lkforce/article/details/109537645">INTERVAL</a></p>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL高级-mysql的架构介绍</title>
      <link href="/2021/10/22/MYSQL%E9%AB%98%E7%BA%A7-mysql%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2021/10/22/MYSQL%E9%AB%98%E7%BA%A7-mysql%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="MYSQL高级"><a href="#MYSQL高级" class="headerlink" title="MYSQL高级"></a>MYSQL高级</h1><h2 id="rpm安装MYSQL-Linux"><a href="#rpm安装MYSQL-Linux" class="headerlink" title="rpm安装MYSQL(Linux)"></a>rpm安装MYSQL(Linux)</h2><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p><a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a><br>下载GA版本(稳定发布版本)【Generally Available】<br><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211022002332.png"><br><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211022002401.png"><br>如果不知道下载32位还64位，可以在linux下使用命令查询<code>getconf LONG_BIT</code></p><h3 id="RPM介绍"><a href="#RPM介绍" class="headerlink" title="RPM介绍"></a>RPM介绍</h3><p>RPM是Red-Hat Package Manager（红帽软件包管理器）的缩写，这一文件格式名称虽然打上了RedHat的标志，但是其原始设计理念是开放式的，包括OpenLinux、S.u.S.E.以及Turbo Linux等Linux的分发版本都有采用，可以算是公认的行业标准了。</p><h3 id="检查当前系统是否安装过mysql"><a href="#检查当前系统是否安装过mysql" class="headerlink" title="检查当前系统是否安装过mysql"></a>检查当前系统是否安装过mysql</h3><p>查询命令：<code>rpm -qa|grep -i mysql</code><br>删除命令：<code>rpm -e RPM软件包(该名字是上一个命令查出来的名字)</code><br><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211022004858.png"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">(<span class="built_in">print</span> work directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">执行 <span class="built_in">pwd</span> 指令可立刻得知您目前所在的工作目录的绝对路径名称。</span></span><br><span class="line">pwd</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote><p><code>-ivh</code>会安装显示进度条</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ivh my</span><br></pre></td></tr></table></figure><ol><li><p>安装Server端 <code>rpm -ivh MySQL-server-5.5.48-1.linux2.6.x86_64.rpm</code><br>安装完后注意提示信息,添加最高权限root的密码<br><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211101170923.png">!</p></li><li><p>安装client端 <code>rpm -ivh MySQL-client-5.5.48-1.linux2.6.x86_64.rpm</code><br>与服务端区别，没有提示信息<br><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211101171416.png"></p></li></ol><h3 id="查看MySQL安装时创建的mysql用户和mysql组"><a href="#查看MySQL安装时创建的mysql用户和mysql组" class="headerlink" title="查看MySQL安装时创建的mysql用户和mysql组"></a>查看MySQL安装时创建的mysql用户和mysql组</h3><p>通过使用<code>cat /etc/passwd | grep mysql</code>和<code>cat /etc/group|grep mysql</code>查看mysql是否安装成功</p><p><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211101174550.png"><br>或则可以执行 <code>mysqladmin --version</code>命令，类似java -version如果打出信息，即为成功。<br><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211101174901.png"></p><p><em><strong>扩展：</strong></em><br><strong>查询linux下的用户</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">id z3</span><br></pre></td></tr></table></figure><p>对于<code>linux</code>系统而言，创建任何用户，都会在<code>home</code>目录下新创用户名文件夹</p><p><strong>cat命令</strong><br>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat [-AbeEnstTuv] [--help] [--version] fileName</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong><br>-n 或 –number：由 1 开始对所有输出的行数编号。<br>-b 或 –number-nonblank：和 -n 相似，只不过对于空白行不编号。<br>-s 或 –squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。<br>-v 或 –show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。<br>-E 或 –show-ends : 在每行结束处显示 $。<br>-T 或 –show-tabs: 将 TAB 字符显示为 ^I。<br>-A, –show-all：等价于 -vET。<br>-e：等价于”-vE”选项；<br>-t：等价于”-vT”选项；</p><p><strong>linux下的<code>|</code>作用</strong><br>利用Linux所提供的管道符“|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为 第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。下面来看看管道是如何在构造一条Linux命令中得到应用的。</p><p><strong>etc/passwd</strong><br>在该文件中，每一行用户记录的各个数据段用“：”分隔，分别定义了用户的各方面属性。各个字段的顺序和含义如下：<br><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211101174550.png"><br>注册名：口令：用户标识号：组标识号：用户名：用户主目录：命令解释程序 </p><h3 id="mysql服务的启-停"><a href="#mysql服务的启-停" class="headerlink" title="mysql服务的启+停"></a>mysql服务的启+停</h3><ol><li>mysql服务启动<code>service mysql start</code><br><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211101180458.png"></li><li>mysql服务启动<code>service mysql stop</code><br><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211101181103.png"></li></ol><p><em><strong>拓展</strong></em><br><code>top</code>命令可以查看linux的运行时间等相关信息</p><h3 id="mysql服务启动后，开始连接"><a href="#mysql服务启动后，开始连接" class="headerlink" title="mysql服务启动后，开始连接"></a>mysql服务启动后，开始连接</h3><ol><li>首次连接成功<blockquote><p>可以见到直接输入<code>mysql</code>命令，直接进入【MySQL默认没有密码，所以这里我们没有输入密码就直接连接上】<br><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211101181925.png"></p></blockquote></li><li>按照安装Server中的提示修改登录密码<br><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211101182506.png"><br>依照mysql规则登录 <code>mysql -u 用户名 -p密码</code><br><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211101182748.png"></li></ol><h3 id="自启动mysql服务"><a href="#自启动mysql服务" class="headerlink" title="自启动mysql服务"></a>自启动mysql服务</h3><ol><li>设置开机自启动mysql<code>chkconfig mysql on</code><br><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211101225500.png"><br>使用<code>chkconfig --list | grep mysql</code>命令，获取如图片的运行级别</li></ol><p><em><strong>扩展</strong></em><br>使用<code>cat /etc/inittab</code>获得<br><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211101230037.png"></p><h3 id="MySQL的安装位置"><a href="#MySQL的安装位置" class="headerlink" title="MySQL的安装位置"></a>MySQL的安装位置</h3><pre><code>  路径                        解释                     备注</code></pre><p>/var/lib/mysql/                 mysql数据库文件的存放路径   默认路径<br>/usr/share/mysql                配置文件目录               mysql.server命令及配置文件<br>/usr/bin                        相关命令目录               mysqladmin mysqldump等命令<br>/etc/init.d/mysql               启停相关脚本</p><h3 id="修改字符集和数据存储路径"><a href="#修改字符集和数据存储路径" class="headerlink" title="修改字符集和数据存储路径"></a>修改字符集和数据存储路径</h3><ol><li><p>查看字符集<br><code>show variables like &#39;character%&#39;;</code><br><code>show variables like &#39;%char%&#39;;</code><br>查看结果<br><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211108094534.png"><br>database和server的value都为latinl</p></li><li><p>修改<br>依照如下图片进行设置<br><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211108102940.png"><br><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211108133724.png"><br>注意在建库<code>database</code>前修改好字符集编码问题，要不然会显示数据中文乱码问题</p></li></ol><p><strong>扩展</strong><br>vim命令下显示序列<br><code>:set nu</code></p><h3 id="MySQL主要配置文件"><a href="#MySQL主要配置文件" class="headerlink" title="MySQL主要配置文件"></a>MySQL主要配置文件</h3><ol><li>windows <code>my.ini</code></li><li>Linux <code>/etc/my.cnf文件</code><h4 id="二进制日志log-bin"><a href="#二进制日志log-bin" class="headerlink" title="二进制日志log-bin"></a>二进制日志log-bin</h4>主从复制</li></ol><h4 id="错误日志log-error"><a href="#错误日志log-error" class="headerlink" title="错误日志log-error"></a>错误日志log-error</h4><p>默认是关闭的，记录严重的警告和错误信息，每次启动和关闭的详细信息等</p><h4 id="查询日志log"><a href="#查询日志log" class="headerlink" title="查询日志log"></a>查询日志log</h4><p>默认关闭，记录查询的sql语句，如果开启会减掉mysql的整体性能，因为记录日志也是需要消耗系统资源</p><h4 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h4><ol><li>两系统<br>windows<br>linux</li><li>frm文件<br>存放表结构</li><li>myd文件<br>存放表数据</li><li>myi文件<br>存放表索引</li></ol><h3 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h3><p><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211108151444.png"></p><ol><li>连接层<br>最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li><li>服务层<br>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存。如果缓存控件足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</li><li>引擎层<br>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MyISAM和InnoDB</li><li>存储层<br>数据存储层，主要是将数据存储在运行于是裸设备的文件系统之上，并完成与存储引擎的交互。</li></ol><h3 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h3><ol><li>如何用命令查看<br>#看你的mysql现在已提供什么存储引擎<br><code>mysql&gt;show engines;</code></li></ol><p>#看你的mysql当前默认的存储引擎<br><code>mysql&gt;show variables like &#39;%storage_engine%&#39;</code><br><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211108155700.png"></p><ol start="2"><li>MyISAM和InnoDB<br><img src="/img/MYSQL%E9%AB%98%E7%BA%A7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211108155928.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile和synchronized区别</title>
      <link href="/2021/10/20/volatile%E5%92%8Csynchronized%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/10/20/volatile%E5%92%8Csynchronized%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>在Java中,为了保证多线程读写数据时保证数据的一致性,可以采用两种方式:</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>如用synchronized关键字,或者使用锁对象.</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>使用volatile关键字<br>用一句话概括volatile,它能够使变量在值发生改变时能尽快地让其他线程知道.</p><h2 id="volatile详解"><a href="#volatile详解" class="headerlink" title="volatile详解"></a>volatile详解</h2><p>首先我们要先意识到有这样的现象,编译器为了加快程序运行的速度,对一些变量的写操作会先在寄存器或者是CPU缓存上进行,最后才写入内存.<br>而在这个过程,变量的新值对其他线程是不可见的.而volatile的作用就是使它修饰的变量的读写操作都必须在内存中进行!</p><h2 id="volatile与synchronized"><a href="#volatile与synchronized" class="headerlink" title="volatile与synchronized"></a>volatile与synchronized</h2><ul><li>volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,- - synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住.</li><li>volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.</li><li>volatile仅能实现变量的修改可见性,但不具备原子特性,而synchronized则可以保证- 变量的修改可见性和原子性.</li><li>volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.</li><li>volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化.</li></ul>]]></content>
      
      
      <categories>
          
          <category> volatile和synchronized区别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile和synchronized区别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM探究</title>
      <link href="/2021/10/14/JVM%E6%8E%A2%E7%A9%B6/"/>
      <url>/2021/10/14/JVM%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://blog.csdn.net/YyjYsj/article/details/115710764">参考笔记</a></p></blockquote><h1 id="JVM探究"><a href="#JVM探究" class="headerlink" title="JVM探究"></a>JVM探究</h1><ul><li>请你谈谈你对JVM的理解？java虚拟机和之前的变化更新?</li><li>什么是OOM，什么是栈溢出StackOverFlowError？怎么分析？</li><li>JVM的常用调优参数有哪些？</li><li>内存快照如何抓取，怎么分析Dump文件？知道吗？</li><li>谈谈JVM中，类加载器你的认识？<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2>c++–减的但是指针和内存管理<h3 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h3><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211014021136.png"></li></ul><ol><li>JVM运行在操作系统（Window，Linux，Mac）上</li><li>JVM底层用C写的</li><li>虚拟机之外的程序与JVM并列</li><li>JRE包含JVM</li></ol><h3 id="JVM的体系结构"><a href="#JVM的体系结构" class="headerlink" title="JVM的体系结构"></a>JVM的体系结构</h3><p><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211014022238.png"></p><ol><li><code>.java</code>文件经过javac命令编译成<code>.class</code>文件</li><li>经过类装载器<code>Class Loader</code>加载到JVM环境中，同时JVM返回与类加载器互动</li><li>执行引擎运行java<br><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211014022718.png"><br><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211014022850.png"></li></ol><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>作用：加载Class文件~</p><blockquote><p>例如：Student student = new Student();引用放在栈中，new的实体对象存放在堆中。<br><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211014030844.png"></p></blockquote><ol><li><code>Car.class</code>进入到JVM中的<code>Class Loader</code>加载、初始化<code>Car Class</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类是模板，对象是具体的</span></span><br><span class="line">Class&lt;Car&gt; carClass = Car.class;</span><br></pre></td></tr></table></figure></li><li>通过<code>Car Class</code>实例化(new)car对象，反过来通过<code>getClass()</code>获取<code>Car Class</code><blockquote><p>可以通过Car.class获取运行时类，也可以通过实例化对象getClass()方法获取运行时类</p></blockquote></li><li><code>Car Class</code>通过<code>getClassLoader</code>获取<code>Class Loader</code></li></ol><p><strong>类加载器</strong></p><ul><li><p>虚拟机自带的加载器</p></li><li><p>启动类(根)加载器（bootstrap class loader）<br>它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。</p></li><li><p>扩展类加载器（ExtClassloader）<br>它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。</p></li><li><p>应用程序(系统类)加载器（AppClassloader）<br>被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。<br><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211014223243.png"></p></li></ul><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制 ***"></a>双亲委派机制 ***</h3><p>双亲委派机制：保证安全,防止核心API库被随意篡改<br>它会先向上委托，App-》Ext-》Boot </p><blockquote><p>由于双亲委派机制逐级向上委托；当boot找到该类则加载，否则报错通知Exc执行；Exc无该类加载报错通知App执行；App执行类加载</p></blockquote><p><strong>总结</strong></p><ol><li>类加载器收到类加载的请求</li><li>将这个请求向上委托给父类加载器去完成，一直向上委托，直到启动类(根)加载器 Boot</li><li>启动类加载器(根)检查是否能够加载当前这个类，能加载则结束，使用当前的加载器，否则，抛出异常，通知子加载类进行加载</li><li>重复步骤3<br>如果最终都没有找到该类，则会报出经典错误<code>Class Not Found~</code></li></ol><h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>组成沙箱的基本组件：</p><ul><li><code>字节码校验器</code>（bytecode verifier）：确保Java文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有类文件都会经过字节码校验，比如核心类。</li><li>类装载器(class loader)：其中类装载器在3个方面对Java沙箱起作用<ol><li>它防止恶意代码去干涉善意的代码;               //双亲委派机制</li><li>它守护了被信任的类库边界；</li><li>它将代码归入保护域，确定了代码可以进行哪些操作。</li></ol></li></ul><h3 id="native"><a href="#native" class="headerlink" title="native  ***"></a>native  ***</h3><p><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211015004553.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;&#125;,<span class="string">&quot;my thread name&quot;</span>).start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// native：凡是带了native关键字的方法，说明java的作用范围达不到了，回去调用底层C语言的库！</span></span><br><span class="line">   <span class="comment">// 会进入本地方法栈</span></span><br><span class="line">   <span class="comment">// 调用本地方法本地接口 JNI 【Java Native Interface】</span></span><br><span class="line">   <span class="comment">// JNI作用：扩展Java的使用，融合不同的编程语言为Java所用！  最初：C、C++</span></span><br><span class="line">   <span class="comment">// Java诞生的时候C、C++ 横行，想要立足，必须要有调用C、C++的程序~</span></span><br><span class="line">   <span class="comment">// 它在内存区域中专门开辟了一块标记区域：Native Method Stack，登记native 方法</span></span><br><span class="line">   <span class="comment">// 在最终执行的时候，加载本地方法库中的方法通过JNI</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//Java程序驱动打印机，管理系统，掌握即可，在企业级应用中较为少见</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//调用其他接口：   Socket..WebService..http~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><p>程序技术器： Program Count Register<br>每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码(用来存储指向像一条指令的地址，也即将要执行的指令代码)，在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211015010911.png"><br>Method Area 方法区<br>方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域，<strong>此区域属于共享区间；</strong></p><blockquote><p>必背：静态变量<code>static</code>、常量<code>final</code>、类<code>Class</code>信息（构造方法、接口定义）、运行时的<code>常量池</code>存在方法区中，但是实例变量存在堆内存中，和方法区无关</p></blockquote><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>1.栈：数据结构<br>    程序 = 数据结构+算法</p><p>栈：先进后出、后进先出<br>队列：先进先出 （FIFO：First Input First Output）</p><p><strong>总结：</strong><br>喝多了吐就是栈，吃多了拉就是队列</p><p>栈：栈内存，主管程序的运行，生命周期和线程同步；<br>线程结束，栈内存也就释放；<br>对于栈来说，不存在垃圾回收问题；<br>一旦线程结束，栈就Over！</p><blockquote><p>栈：8大基本数据类型+对象引用+实例方法<br><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211015014222.png"><br><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211015014424.png"><br>栈满了则会抛出<code>StackOverflowError</code></p></blockquote><p>栈+堆+方法区：交互关系<br><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211015015017.png"></p><h3 id="三种JVM"><a href="#三种JVM" class="headerlink" title="三种JVM"></a>三种JVM</h3><ul><li>Sun公司HotSpot <code>Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)</code></li><li>BEA <code>JRockit</code></li><li>IBM <code>J9VM</code></li></ul><p>我们学习都是：<code>HotSpot</code></p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。<br>类加载器读取了类文件后，一般会把什么东西放到堆中？类，方法，常量，变量~，保存我们所有引用类型的真实对象;<br>堆内存中还要细分为三个区域：</p><ul><li>新生区(伊甸园区) Young/New</li><li>老年区 Old</li><li>永久区 Per<br><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211016140216.png"><br>GC垃圾回收，主要是在伊甸园区和老年区~<br>假设内存满了，OOM，堆内存不够！java.lang.OutOfMemoryError:Java heap space<br>在JDK8以后，永久存储区改了个名字(元空间);<br><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211019134329.png"></li></ul><h3 id="新生区-伊甸园区"><a href="#新生区-伊甸园区" class="headerlink" title="新生区(伊甸园区)"></a>新生区(伊甸园区)</h3><p>轻GC：Young GC<br>重GC：Full GC<br>Old GC :指的是老年区垃圾回收<br>假设伊甸园区只能存10个对象，当满了10个以后就会触发<code>轻GC</code>,如果有的对象还存在引用，则存活下来进入幸存者区;反之没用则死亡。<code>轻GC</code>后将幸存者区中的对象放回伊甸园区重复上操作;</p><h3 id="老年区"><a href="#老年区" class="headerlink" title="老年区"></a>老年区</h3><p>当新生区（伊甸园区和幸存者区）都满的情况，则触发重GC，将清理幸存者区并且将幸存区存活下来的对象移到养老区，如果清理过后幸存区仍然放不下对象，则重GC会将对象直接放到养老区中，如果养老区也不足以放下对象，则会产生OOM；</p><blockquote><p>真理：经过研究，99%的对象都是临时对象！</p></blockquote><h3 id="永久区"><a href="#永久区" class="headerlink" title="永久区"></a>永久区</h3><p>这个区域常驻内存的。用来存放JDK自身携带的Class对象，Interface元数据，存储的是Java运行时的一些环境或类信息<del>这个区域不存在垃圾回收！关闭JVM虚拟机就会释放这个区域的内存</del><br>一个启动类，加载了大量的第三方jar包。Tomcat部署了太多的应用，大量动态生成的反射类。不断的被加载。直到内存满，就会出现OOM;</p><ul><li>JDK1.6之前：永久代，常量池在方法区</li><li>JDK1.7：永久代，但是慢慢的退化了，<code>去永久代</code>,常量池在堆中</li><li>JKD1.8之后：无永久代，常量池在元空间<br><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211019134714.png"></li></ul><p><strong>代码探究JVM</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回虚拟机试图使用的最大内存</span></span><br><span class="line">    <span class="keyword">long</span> max = Runtime.getRuntime().maxMemory();<span class="comment">//字节 1024*1024</span></span><br><span class="line">    <span class="comment">//返回jvm的初始化总内存</span></span><br><span class="line">    <span class="keyword">long</span> total = Runtime.getRuntime().totalMemory();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;max=&quot;</span>+max+<span class="string">&quot;字节\t&quot;</span>+(max/(<span class="keyword">double</span>)<span class="number">1024</span>/<span class="number">1024</span>)+<span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;total=&quot;</span>+total+<span class="string">&quot;字节\t&quot;</span>+(total/(<span class="keyword">double</span>)<span class="number">1024</span>/<span class="number">1024</span>)+<span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    <span class="comment">//默认情况下：分配的总内存 是电脑内存的1/4，而初始化的内存：1/64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OOM:</span></span><br><span class="line">    <span class="comment">//1.尝试扩大推内存看结果</span></span><br><span class="line">    <span class="comment">//JVM设置：-Xms1024m -Xmx1024m -XX:+PrintGCDetails</span></span><br><span class="line">    <span class="comment">//2.分析内存，看一下那个地方出现了问题(专业工具)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//305664K + 699392K = 1,005,056K = 981.5MB</span></span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">max=1029177344字节981.5MB</span><br><span class="line">total=1029177344字节981.5MB</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 305664K, used 20971K [0x00000000eab00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 262144K, 8% used [0x00000000eab00000,0x00000000ebf7afb8,0x00000000fab00000)</span><br><span class="line">  from space 43520K, 0% used [0x00000000fd580000,0x00000000fd580000,0x0000000100000000)</span><br><span class="line">  to   space 43520K, 0% used [0x00000000fab00000,0x00000000fab00000,0x00000000fd580000)</span><br><span class="line"> ParOldGen       total 699392K, used 0K [0x00000000c0000000, 0x00000000eab00000, 0x00000000eab00000)</span><br><span class="line">  object space 699392K, 0% used [0x00000000c0000000,0x00000000c0000000,0x00000000eab00000)</span><br><span class="line"> Metaspace       used 3533K, capacity 4502K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 391K, capacity 394K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>在一个项目中，突然出现了OOM故障，那么该如何排除～研究为什么出错～</strong></p><ul><li>能够看到代码第几行出错：内存快照分析工具，MAT，Jprofiler</li><li>DeBug,一行行分析代码！</li></ul><p><strong>MAT,Jrofiler作用：</strong></p><ul><li>分析Dump内存文件，快速定位内存泄露；</li><li>获取堆中数据</li><li>获得大的对象~</li><li>…</li></ul><p><strong>测试JProfiler</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Dump</span></span><br><span class="line"><span class="comment">//-Xms 设置初始化内存分配大小  默认1/64</span></span><br><span class="line"><span class="comment">//-Xmx 设置最大分配内存       默认1/4</span></span><br><span class="line"><span class="comment">//-XX:+PrintGCDetails                      //打印GC垃圾回收信息</span></span><br><span class="line"><span class="comment">//-XX:+HeapDumpOnOutOfMemoryError          //oom DUMP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>];<span class="comment">//1m</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Demo3&gt; list = <span class="keyword">new</span> ArrayList&lt;Demo3&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> Demo3());<span class="comment">//问题所在</span></span><br><span class="line">                count= count +<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;count:&quot;</span>+count);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GC：垃圾回收"><a href="#GC：垃圾回收" class="headerlink" title="GC：垃圾回收"></a>GC：垃圾回收</h3><p>GC的作用区域在堆+方法区<br>JVM在进行GC时，并不是对着三个区域统一回收。大部分时候，回收都是新生代~</p><ul><li>新生代</li><li>幸存区(from,to)</li><li>老年区<br>GC两种类：轻GC(普通的GC)，重GC(全局GC)</li></ul><p><strong>GC题目：</strong></p><ul><li>JVM的内存模型和分区~详细到每个区放什么？</li><li>堆里面的分区有哪些？Eden,from,to,老年区，说说他们的特点！</li><li>GC的算法有哪些？标记清除法，标记压缩，复制算法，引用计数器，怎么用的?</li><li>轻GC和重GC分别在什么时候发生？</li></ul><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211020183657.png"><br>计数为0的被清除</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211020191947.png"><br>复制算法为了保证to区干净，所以谁空谁是幸运区to</p><ol><li>每次GC 都会将Eden存活的对象移到幸存区中;一旦Eden区被GC后，就会是空的！</li><li>当一个对象经历了15次GC，都还没有死 <code>-XX:MaxTenuringThreshold=15</code>通过这个参数可以设定进入老年代的时间<br><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211020192424.png"><br><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211020192533.png"></li></ol><p><strong>优缺点：</strong></p><ul><li>好处：没有内存的碎片~</li><li>坏处：浪费了内存空间~：多了一般空间永远是空to。假设对象100%存活(极端情况)</li></ul><p>复制算法最佳使用场景：对象存货度较低的时候;新生区~</p><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211020193428.png"></p><p><strong>优缺点</strong></p><ul><li>优点：不需要额外的空间！</li><li>缺点：两次扫描，严重浪费时间，会产生内存碎片。</li></ul><h3 id="标记压缩"><a href="#标记压缩" class="headerlink" title="标记压缩"></a>标记压缩</h3><p>对标记清除再优化<br>先标记清除几次，再进行标记压缩<br><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211020194016.png"></p><h3 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h3><p>内存效率：复制算法&gt;标记清楚算法&gt;标记压缩算法(时间复杂度)<br>内存整齐度：复制算法=标记压缩算法&gt;标记清除算法<br>内存利用率：标记压缩算法=标记清除算法&gt;复制算法</p><p>思考一个问题：难道没有最优算法吗？<br>答案：没有，没有最好的算法，只有最合适的算法—&gt;GC：分代收集算法</p><p><strong>年轻代：</strong></p><ul><li>存活率低</li><li>复制算法！</li></ul><p><strong>老年代：</strong></p><ul><li>区域大：存活率大</li><li>标记清除(内存碎片不是太多)+标记压缩混合实现</li></ul><h3 id="JMM：Java-Memory-Model"><a href="#JMM：Java-Memory-Model" class="headerlink" title="JMM：Java Memory Model"></a>JMM：Java Memory Model</h3><ol><li>什么是JMM？<br>JMM:(Java Memory Model)</li><li>它干嘛的？:官方，其他人的博客，对应的视频！<br>作用：缓存一致性协议，用于定义数据读写的规则(遵守，找到这个规则)<br>JMM定义了线程工作内存和主内存之间的抽象关系：线程之间的共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存(Local Memory)<br><img src="/img/jvm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211020232851.png"><br>解决共享对象可见性这个问题：volatile</li><li>它该如何学习？<br>JMM：抽象的概念，理论<br>JMM对这8种指令的使用，制定了如下规则：</li></ol><ul><li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用store必须write</li><li>不允许线程丢弃他最近assign操作，即工作变量的数据改变了之后，必须告知主存</li><li>不允许一个线程将没有assign的数据从工作内存同步回主内存</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接是哦那个一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</li><li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</li><li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或则assign操作初始化变量的值</li><li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</li><li>对一个变量进行unlock操作之前，必须把此变量同步回主内存<br>JMM对着8种操作规则和对volatile的一些特殊规则就能确定哪里操作是线程安全，哪些操作是线程不安全的了。但是这些规则实在复杂，很难在实践种直接分析。所以一般我们也不会通过上述规则进行分析。更多的时候，使用java的happen-before规则来进行分析。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>首页数据添加Redis缓存</title>
      <link href="/2021/10/10/%E9%A6%96%E9%A1%B5%E6%95%B0%E6%8D%AE%E6%B7%BB%E5%8A%A0Redis%E7%BC%93%E5%AD%98/"/>
      <url>/2021/10/10/%E9%A6%96%E9%A1%B5%E6%95%B0%E6%8D%AE%E6%B7%BB%E5%8A%A0Redis%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h1><p>Redis是当前比较热门的NOSQL系统之一，它是一个开源的使用ANSI c语言编写的key-value存储系统（区别于MySQL的二维表格的形式存储。）。和Memcache类似，但很大程度补偿了Memcache的不足。和Memcache一样，Redis数据都是缓存在计算机内存中，不同的是，Memcache只能将数据缓存到内存中，无法自动定期写入硬盘，这就表示，一断电或重启，内存清空，数据丢失。所以Memcache的应用场景适用于缓存无需持久化的数据。而Redis不同的是它会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，实现数据的持久化。</p><p>Redis的特点：</p><p>1，Redis读取的速度是110000次/s，写的速度是81000次/s；</p><p>2，原子 。Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</p><p>3，支持多种数据结构：string（字符串）；list（列表）；hash（哈希），set（集合）；zset(有序集合)</p><p>4，持久化，集群部署</p><p>5，支持过期时间，支持事务，消息订阅</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>基于key-value进行存储的</li><li>支持多种数据结构：string(字符串)、list(列表)、hash(哈希)、set(集合)、zset(有序集合)</li><li>支持持久化，通过内存进行存储的，也可以存到硬盘里面</li><li>支持过期时间，支持事务</li><li><strong>一般来说，把经常进行查询，不经常修改,不是特别重要的数据放到redis作为缓存</strong></li></ul><h1 id="项目集成Redis"><a href="#项目集成Redis" class="headerlink" title="项目集成Redis"></a>项目集成Redis</h1><h2 id="在common模块添加依赖"><a href="#在common模块添加依赖" class="headerlink" title="在common模块添加依赖"></a>在common模块添加依赖</h2><p>由于redis缓存是公共应用，所以我们把依赖与配置添加到了common模块下面，在common模块pom.xml下添加以下依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="在service-base模块添加redis配置类"><a href="#在service-base模块添加redis配置类" class="headerlink" title="在service-base模块添加redis配置类"></a>在service-base模块添加redis配置类</h2><p>RedisConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">//key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">        <span class="comment">//value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//value hashmap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        <span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">              .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在接口中添加redis缓存"><a href="#在接口中添加redis缓存" class="headerlink" title="在接口中添加redis缓存"></a>在接口中添加redis缓存</h2><p>由于首页数据变化不是很频繁，而且首页访问量相对较大，所以我们有必要把首页接口数据缓存到redis缓存中，减少数据库压力和提高访问速度。<br>改造service-cms模块首页banner接口，首页课程与讲师接口类似</p><h3 id="Spring-Boot缓存注解"><a href="#Spring-Boot缓存注解" class="headerlink" title="Spring Boot缓存注解"></a>Spring Boot缓存注解</h3><p>（1）缓存@Cacheable<br>一般用于查询方法中<br>第一次查询，首先查询数据库，把数据库查询数据返回，并且返回数据放到缓存中<br>第二次查询，查询缓存，发现缓存有数据，直接返回</p><p>查看源码，属性值如下：<br><img src="/img/redis/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211010214539.png"></p><p>（2）缓存@CachePut<br>使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库。一般用在新增方法上。</p><p>查看源码，属性值如下：<br><img src="/img/redis/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211010215133.png"></p><p>（3）缓存@CacheEvict<br>使用该注解标志的方法，会清空指定的缓存。一般用在更新或者删除方法上</p><p>查看源码，属性值如下：<br><img src="/img/redis/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211010215418.png"></p><h3 id="SpringBoot关于redis手写"><a href="#SpringBoot关于redis手写" class="headerlink" title="SpringBoot关于redis手写"></a>SpringBoot关于redis手写</h3><p>首先引入redis依赖，application.properties配置redis，配置redis配置Configuration类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手写redis获取、放置缓存内容</span></span><br><span class="line">        redisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="linux开启redis服务"><a href="#linux开启redis服务" class="headerlink" title="linux开启redis服务"></a>linux开启redis服务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install gcc-c++</span><br><span class="line">yum install -y tcl</span><br><span class="line">yum install wget</span><br><span class="line">wget http://download.redis.io/releases/redis-6.2.4.tar.gz</span><br><span class="line">tar -zxvf redis-6.2.4.tar.gz</span><br><span class="line">mv redis-3.2.01 /usr/local/redis</span><br><span class="line">cd /usr/local/redis</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">mkdir -p /etc/redis</span><br><span class="line">cp redis.conf /etc/redis</span><br><span class="line">（</span><br><span class="line">vi /etc/redis/redis.conf</span><br><span class="line">　　仅修改： daemonize yes （no--yes））</span><br><span class="line">/usr/local/bin/redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><h3 id="使用linux进入redis-cli【客户端】"><a href="#使用linux进入redis-cli【客户端】" class="headerlink" title="使用linux进入redis-cli【客户端】"></a>使用linux进入redis-cli【客户端】</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./redis-cli</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">//查询所有key</span><br><span class="line">keys *</span><br><span class="line"></span><br><span class="line">//获取key的value值</span><br><span class="line">get  key</span><br><span class="line"></span><br><span class="line">//删除缓存记录</span><br><span class="line">del key</span><br></pre></td></tr></table></figure><h3 id="连接redis服务可能遇到的问题"><a href="#连接redis服务可能遇到的问题" class="headerlink" title="连接redis服务可能遇到的问题"></a>连接redis服务可能遇到的问题</h3><p>（1）关闭liunx防火墙</p><p>（2）找到redis配置文件， 注释一行配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注释掉这句话</span><br><span class="line"># bind 127.0.0.1</span><br></pre></td></tr></table></figure><p>（3）如果出现下面错误提示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by:io.lettuce.core.RedisConnectionException:DENIED Redis is running in protected mode because protected mode is enabled,</span><br></pre></td></tr></table></figure><p>修改protected-mode yes<br>改为<br>protected-mode no</p>]]></content>
      
      
      <categories>
          
          <category> 在线教育项目 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在线教育项目 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>首页显示banner数据【数据】</title>
      <link href="/2021/10/09/%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BAbanner%E6%95%B0%E6%8D%AE%E3%80%90%E6%95%B0%E6%8D%AE%E3%80%91/"/>
      <url>/2021/10/09/%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BAbanner%E6%95%B0%E6%8D%AE%E3%80%90%E6%95%B0%E6%8D%AE%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="首页数据banner显示-幻灯片或轮播图"><a href="#首页数据banner显示-幻灯片或轮播图" class="headerlink" title="首页数据banner显示(幻灯片或轮播图)"></a>首页数据banner显示(幻灯片或轮播图)</h1><h2 id="在service创建子模块service-cms"><a href="#在service创建子模块service-cms" class="headerlink" title="在service创建子模块service_cms"></a>在service创建子模块service_cms</h2>]]></content>
      
      
      <categories>
          
          <category> 在线教育项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在线教育项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务端渲染技术NUXT</title>
      <link href="/2021/10/09/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AFNUXT/"/>
      <url>/2021/10/09/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AFNUXT/</url>
      
        <content type="html"><![CDATA[<h1 id="服务端渲染技术NUXT"><a href="#服务端渲染技术NUXT" class="headerlink" title="服务端渲染技术NUXT"></a>服务端渲染技术NUXT</h1><h2 id="什么是服务端渲染"><a href="#什么是服务端渲染" class="headerlink" title="什么是服务端渲染"></a>什么是服务端渲染</h2><p>服务端渲染又称SSR (Server Side Render)是在服务端完成页面的内容，而不是在客户端通过AJAX获取数据。</p><p>服务器端渲染(SSR)的优势主要在于：<strong>更好的 SEO</strong>，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。</p><p>如果你的应用程序初始展示 loading 菊花图，然后通过 Ajax 获取内容，抓取工具并不会等待异步完成后再进行页面内容的抓取。也就是说，如果 SEO 对你的站点至关重要，而你的页面又是异步获取内容，则你可能需要服务器端渲染(SSR)解决此问题。</p><p>另外，使用服务器端渲染，我们可以获得更快的内容到达时间(time-to-content)，无需等待所有的 JavaScript 都完成下载并执行，产生更好的用户体验，对于那些「内容到达时间(time-to-content)与转化率直接相关」的应用程序而言，服务器端渲染(SSR)至关重要。</p><h2 id="什么是NUXT"><a href="#什么是NUXT" class="headerlink" title="什么是NUXT"></a>什么是NUXT</h2><p>Nuxt.js 是一个基于 Vue.js 的轻量级应用框架,可用来创建服务端渲染 (SSR) 应用,也可充当静态站点引擎生成静态站点应用,具有优雅的代码结构分层和热加载等特性。</p><p>官网网站：<br><a href="https://zh.nuxtjs.org/">https://zh.nuxtjs.org/</a></p><h1 id="NUXT环境初始化"><a href="#NUXT环境初始化" class="headerlink" title="NUXT环境初始化"></a>NUXT环境初始化</h1><h2 id="下载压缩包"><a href="#下载压缩包" class="headerlink" title="下载压缩包"></a>下载压缩包</h2><p><a href="https://github.com/nuxt-community/starter-template/archive/master.zip">https://github.com/nuxt-community/starter-template/archive/master.zip</a></p><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>将template中的内容复制到 guli</p><h2 id="安装ESLint"><a href="#安装ESLint" class="headerlink" title="安装ESLint"></a>安装ESLint</h2><p>将guli-admin项目下的.eslintrc.js配置文件复制到当前项目下</p><h2 id="修改package-json"><a href="#修改package-json" class="headerlink" title="修改package.json"></a>修改package.json</h2><p>name、description、author（必须修改这里，否则项目无法安装）</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;guli&quot;</span>,</span><br><span class="line"><span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line"><span class="string">&quot;description&quot;</span>: <span class="string">&quot;谷粒学院前台网站&quot;</span>,</span><br><span class="line"><span class="string">&quot;author&quot;</span>: <span class="string">&quot;Helen &lt;55317332@qq.com&gt;&quot;</span>,</span><br></pre></td></tr></table></figure><h2 id="修改nuxt-config-js"><a href="#修改nuxt-config-js" class="headerlink" title="修改nuxt.config.js"></a>修改nuxt.config.js</h2><p>修改title: <code>&#123;&#123; name &#125;&#125;</code>、content: <code>&#123;&#123;escape description &#125;&#125;</code><br>这里的设置最后会显示在页面标题栏和meta数据中</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">head: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;谷粒学院 - Java视频|HTML5视频|前端视频|Python视频|大数据视频-自学拿1万+月薪的IT在线视频课程，谷粉力挺，老学员为你推荐&#x27;</span>,</span><br><span class="line">    <span class="attr">meta</span>: [</span><br><span class="line">      &#123; <span class="attr">charset</span>: <span class="string">&#x27;utf-8&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&#x27;viewport&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;width=device-width, initial-scale=1&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">hid</span>: <span class="string">&#x27;keywords&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;keywords&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;谷粒学院,IT在线视频教程,Java视频,HTML5视频,前端视频,Python视频,大数据视频&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">hid</span>: <span class="string">&#x27;description&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;description&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;谷粒学院是国内领先的IT在线视频学习平台、职业教育平台。截止目前,谷粒学院线上、线下学习人次数以万计！会同上百个知名开发团队联合制定的Java、HTML5前端、大数据、Python等视频课程，被广大学习者及IT工程师誉为：业界最适合自学、代码量最大、案例最多、实战性最强、技术最前沿的IT系列视频课程！&#x27;</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">link</span>: [</span><br><span class="line">      &#123; <span class="attr">rel</span>: <span class="string">&#x27;icon&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;image/x-icon&#x27;</span>, <span class="attr">href</span>: <span class="string">&#x27;/favicon.ico&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="NUXT目录结构"><a href="#NUXT目录结构" class="headerlink" title="NUXT目录结构"></a>NUXT目录结构</h2><ul><li>资源目录 assets</li></ul><p> 用于组织未编译的静态资源如 LESS、SASS 或 JavaScript。</p><ul><li>组件目录 components</li></ul><p>用于组织应用的 Vue.js 组件。Nuxt.js 不会扩展增强该目录下 Vue.js 组件，即这些组件不会像页面组件那样有 asyncData 方法的特性。</p><ul><li>布局目录 layouts</li></ul><p>用于组织应用的布局组件。</p><ul><li>页面目录 pages</li></ul><p>用于组织应用的路由及视图。Nuxt.js 框架读取该目录下所有的 .vue 文件并自动生成对应的路由配置。</p><ul><li>插件目录 plugins</li></ul><p>用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。</p><ul><li>nuxt.config.js 文件</li></ul><p>nuxt.config.js 文件用于组织Nuxt.js 应用的个性化配置，以便覆盖默认配置。</p><h1 id="幻灯片插件"><a href="#幻灯片插件" class="headerlink" title="幻灯片插件"></a>幻灯片插件</h1><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install vue-awesome-swiper</span><br></pre></td></tr></table></figure><h2 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h2><p>在 plugins 文件夹下新建文件 nuxt-swiper-plugin.js，内容是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import VueAwesomeSwiper from &#x27;vue-awesome-swiper/dist/ssr&#x27;</span><br><span class="line"></span><br><span class="line">Vue.use(VueAwesomeSwiper)</span><br></pre></td></tr></table></figure><p>在 nuxt.config.js 文件中配置插件<br>将 plugins 和 css节点 复制到 module.exports节点下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // some nuxt config...</span><br><span class="line">  plugins: [</span><br><span class="line">    &#123; src: &#x27;~/plugins/nuxt-swiper-plugin.js&#x27;, ssr: false &#125;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  css: [</span><br><span class="line">    &#x27;swiper/dist/css/swiper.css&#x27;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>npm run dev 指令运行时报错，由于是我们导入的import ‘swiper/css/swiper.css’在低版本中有，Swiper 6.0.0或者更高版本就不是这个导入地址了，所以以下为解决方案。</p></blockquote><ol><li>把安装的vue-awesome-swiper版本回退到低版本，这样就可以保留import ‘swiper/css/swiper.css’:</li><li>指令为: npm i <a href="mailto:&#118;&#x75;&#101;&#x2d;&#97;&#119;&#101;&#x73;&#111;&#x6d;&#101;&#x2d;&#115;&#x77;&#x69;&#112;&#x65;&#x72;&#x40;&#51;&#x2e;&#49;&#x2e;&#51;">&#118;&#x75;&#101;&#x2d;&#97;&#119;&#101;&#x73;&#111;&#x6d;&#101;&#x2d;&#115;&#x77;&#x69;&#112;&#x65;&#x72;&#x40;&#51;&#x2e;&#49;&#x2e;&#51;</a> –save</li></ol><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="固定路由"><a href="#固定路由" class="headerlink" title="固定路由"></a>固定路由</h2><p>（1）使用router-link构建路由，地址是/course</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;li&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;current&quot;</span> <span class="attr">exact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）在page目录创建文件夹course ，在course目录创建index.vue</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    课程列表</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>（1）创建方式<br>如果我们需要根据id查询一条记录，就需要使用动态路由。<strong>NUXT的动态路由是以下划线开头的vue文件，参数名为下划线后边的文件名</strong></p><p>在pages下的course目录下创建**_id.vue**,补充内容</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    讲师详情</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h1><p>我们可以参考guli-admin将axios操作封装起来<br>下载axios ，使用命令 <code>npm install axios</code><br>创建utils文件夹，utils下创建request.js</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">// 创建axios实例</span><br><span class="line">const service = axios.create(&#123;</span><br><span class="line">  baseURL: &#x27;http://localhost:9001&#x27;, // api的base_url   【nginx】</span><br><span class="line">  timeout: 20000 // 请求超时时间</span><br><span class="line">&#125;)</span><br><span class="line">export default service</span><br></pre></td></tr></table></figure><h1 id="首页banner数据显示"><a href="#首页banner数据显示" class="headerlink" title="首页banner数据显示"></a>首页banner数据显示</h1><h2 id="创建api文件夹，创建banner-js文件"><a href="#创建api文件夹，创建banner-js文件" class="headerlink" title="创建api文件夹，创建banner.js文件"></a>创建api文件夹，创建banner.js文件</h2><p>banner.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&#x27;@/utils/request&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">getList</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">`/educms/banner/getAllBanner`</span>,</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在页面调用接口得到数据进行显示"><a href="#在页面调用接口得到数据进行显示" class="headerlink" title="在页面调用接口得到数据进行显示"></a>在页面调用接口得到数据进行显示</h2><p>在index.vue进行调用</p><blockquote><p>v-for=”banner in bannerList” :key=”banner.id” 【注意需要加上:key标识每一个对象唯一标识】<br><img :src="banner.imgUrl" :alt="banner.title"> 【alt有两种标识：1、光标到图片显示文字内容 2、无图片显示文字内容】</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 在线教育项目 </category>
          
          <category> 服务端渲染技术NUXT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在线教育项目 </tag>
            
            <tag> 服务端渲染技术NUXT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>熔断器</title>
      <link href="/2021/10/08/%E7%86%94%E6%96%AD%E5%99%A8/"/>
      <url>/2021/10/08/%E7%86%94%E6%96%AD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Hystrix基本概念"><a href="#Hystrix基本概念" class="headerlink" title="Hystrix基本概念"></a>Hystrix基本概念</h1><h2 id="Spring-Cloud调用接口过程"><a href="#Spring-Cloud调用接口过程" class="headerlink" title="Spring Cloud调用接口过程"></a>Spring Cloud调用接口过程</h2><p>Spring Cloud 在接口调用上，大致会经过如下几个组件配合：</p><p>Feign —–&gt;Hystrix —&gt;Ribbon —&gt;Http Client（apache http components 或者 Okhttp） 具体交互流程上，如下图所示：<br><img src="/img/SpringCloud/d5be6f27-caff-45b6-8f27-837ea6b11134.jpg"></p><ul><li><p>接口化请求调用当调用被@FeignClient注解修饰的接口时，在框架内部，将请求转换成Feign的请求实例feign.Request，交由Feign框架处理。</p></li><li><p>Feign ：转化请求Feign是一个http请求调用的轻量级框架，可以以Java接口注解的方式调用Http请求，封装了Http调用流程。</p></li><li><p>Hystrix：熔断处理机制 Feign的调用关系，会被Hystrix代理拦截，对每一个Feign调用请求，Hystrix都会将其包装成HystrixCommand,参与Hystrix的流控和熔断规则。如果请求判断需要熔断，则Hystrix直接熔断，抛出异常或者使用FallbackFactory返回熔断Fallback结果；如果通过，则将调用请求传递给Ribbon组件。</p></li><li><p>Ribbon：服务地址选择 当请求传递到Ribbon之后,Ribbon会根据自身维护的服务列表，根据服务的服务质量，如平均响应时间，Load等，结合特定的规则，从列表中挑选合适的服务实例，选择好机器之后，然后将机器实例的信息请求传递给Http Client客户端，HttpClient客户端来执行真正的Http接口调用；</p></li><li><p>HttpClient ：Http客户端，真正执行Http调用根据上层Ribbon传递过来的请求，已经指定了服务地址，则HttpClient开始执行真正的Http请求</p></li></ul><h2 id="Hystrix概念"><a href="#Hystrix概念" class="headerlink" title="Hystrix概念"></a>Hystrix概念</h2><p>Hystrix 是一个供分布式系统使用，提供延迟和容错功能，保证复杂的分布系统在面临不可避免的失败时，仍能有其弹性。<br>比如系统中有很多服务，当某些服务不稳定的时候，使用这些服务的用户线程将会阻塞，如果没有隔离机制，系统随时就有可能会挂掉，从而带来很大的风险。SpringCloud使用Hystrix组件提供断路器、资源隔离与自我修复功能。下图表示服务B触发了断路器，阻止了级联失败<br><img src="/img/SpringCloud/59809c07-0923-4546-aa83-ed920f53a3a5.jpg"></p><h2 id="feign结合Hystrix使用"><a href="#feign结合Hystrix使用" class="headerlink" title="feign结合Hystrix使用"></a>feign结合Hystrix使用</h2><p><strong>改造service-edu模块</strong></p><h3 id="在service的pom中添加依赖"><a href="#在service的pom中添加依赖" class="headerlink" title="在service的pom中添加依赖"></a>在service的pom中添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--hystrix依赖，主要是用  @HystrixCommand --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--服务注册--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--服务调用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在配置文件中添加hystrix配置"><a href="#在配置文件中添加hystrix配置" class="headerlink" title="在配置文件中添加hystrix配置"></a>在配置文件中添加hystrix配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#开启熔断机制</span><br><span class="line">feign.hystrix.enabled=true</span><br><span class="line"># 设置hystrix超时时间，默认1000ms</span><br><span class="line">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=6000</span><br></pre></td></tr></table></figure><h3 id="在service-edu的client包里面创建熔断器的实现类"><a href="#在service-edu的client包里面创建熔断器的实现类" class="headerlink" title="在service-edu的client包里面创建熔断器的实现类"></a>在service-edu的client包里面创建熔断器的实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VodFileDegradeFeignClient</span> <span class="keyword">implements</span> <span class="title">VodClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">removeVideo</span><span class="params">(String videoId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> R.error().message(<span class="string">&quot;time out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">removeVideoList</span><span class="params">(List videoIdList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> R.error().message(<span class="string">&quot;time out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改VodClient接口的注解"><a href="#修改VodClient接口的注解" class="headerlink" title="修改VodClient接口的注解"></a>修改VodClient接口的注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;service-vod&quot;, fallback = VodFileDegradeFeignClient.class)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">VodClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DeleteMapping(value = &quot;/eduvod/vod/&#123;videoId&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">removeVideo</span><span class="params">(<span class="meta">@PathVariable(&quot;videoId&quot;)</span> String videoId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(value = &quot;/eduvod/vod/delete-batch&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">removeVideoList</span><span class="params">(<span class="meta">@RequestParam(&quot;videoIdList&quot;)</span> List videoIdList)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 在线教育项目 </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在线教育项目 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus知识点</title>
      <link href="/2021/10/07/MybatisPlus%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2021/10/07/MybatisPlus%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="mp中查询指定字段"><a href="#mp中查询指定字段" class="headerlink" title="mp中查询指定字段"></a>mp中查询指定字段</h2><p>IdsWrapper.select(“字段名”)</p>]]></content>
      
      
      <categories>
          
          <category> 随手记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MybaitsPlus </tag>
            
            <tag> 随手记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速将一个List或数组用特定符号拼接</title>
      <link href="/2021/10/07/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%B0%86%E4%B8%80%E4%B8%AAList%E6%88%96%E6%95%B0%E7%BB%84%E7%94%A8%E7%89%B9%E5%AE%9A%E7%AC%A6%E5%8F%B7%E6%8B%BC%E6%8E%A5/"/>
      <url>/2021/10/07/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%B0%86%E4%B8%80%E4%B8%AAList%E6%88%96%E6%95%B0%E7%BB%84%E7%94%A8%E7%89%B9%E5%AE%9A%E7%AC%A6%E5%8F%B7%E6%8B%BC%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在日常开发中，我们总会有需要list或则数组使用特定符号进行拼接操作。第一个思路就是有循环然后进行拼接组合</p></blockquote><p>当然也有工具类，使得代码简化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;22&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;33&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//11,22,33</span></span><br><span class="line">        <span class="comment">//import org.apache.commons.lang.StringUtils;</span></span><br><span class="line">        String join = StringUtils.join(list.toArray(), <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        System.out.println(join);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 在线教育项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手记 </tag>
            
            <tag> 在线教育项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@RequestParam加与不加的区别</title>
      <link href="/2021/10/07/RequestParam%E5%8A%A0%E4%B8%8E%E4%B8%8D%E5%8A%A0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/10/07/RequestParam%E5%8A%A0%E4%B8%8E%E4%B8%8D%E5%8A%A0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="RequestParam加与不加的区别"><a href="#RequestParam加与不加的区别" class="headerlink" title="@RequestParam加与不加的区别"></a>@RequestParam加与不加的区别</h1><p>最简单的两种写法，加或不加@RequestParam注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="meta">@RequestParam</span> <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>第一种写法参数为非必传，第二种写法参数为必传。参数名为userId。</li><li>第二种写法可以通过@RequestParam(required = false)设置为非必传。因为required值默认是true，所以默认必传。</li><li>第二种写法可以通过@RequestParam(“userId”)或者@RequestParam(value = “userId”)指定参数名。</li><li>第二种写法可以通过@RequestParam(defaultValue = “0”)指定参数默认值</li></ul><p>用法如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="meta">@RequestParam(value = &quot;userId&quot;, defaultValue = &quot;0&quot;, required = false)</span> <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 在线教育项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手记 </tag>
            
            <tag> 在线教育项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务调用-Feign</title>
      <link href="/2021/10/07/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8-Feign/"/>
      <url>/2021/10/07/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8-Feign/</url>
      
        <content type="html"><![CDATA[<h1 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>Feign是Netflix开发的声明式、模板化的HTTP客户端， Feign可以帮助我们更快捷、优雅地调用HTTP API。</li><li>Feign支持多种注解，例如Feign自带的注解或者JAX-RS注解等。</li><li>Spring Cloud对Feign进行了增强，使Feign支持了Spring MVC注解，并整合了Ribbon和Eureka，从而让Feign的使用更加方便。</li><li>Spring Cloud Feign是基于Netflix feign实现，整合了Spring Cloud Ribbon和Spring Cloud Hystrix，除了提供这两者的强大功能外，还提供了一种声明式的Web服务客户端定义的方式。</li><li>Spring Cloud Feign帮助我们定义和实现依赖服务接口的定义。在Spring Cloud feign的实现下，只需要创建一个接口并用注解方式配置它，即可完成服务提供方的接口绑定，简化了在使用Spring Cloud Ribbon时自行封装服务调用客户端的开发量。<h2 id="实现服务调用"><a href="#实现服务调用" class="headerlink" title="实现服务调用"></a>实现服务调用</h2></li></ul><h3 id="引入依赖在service模块"><a href="#引入依赖在service模块" class="headerlink" title="引入依赖在service模块"></a>引入依赖在service模块</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--服务调用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在调用端的启动类添加注解"><a href="#在调用端的启动类添加注解" class="headerlink" title="在调用端的启动类添加注解"></a>在调用端的启动类添加注解</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableFeignClients</span><br></pre></td></tr></table></figure><h3 id="创建包和接口"><a href="#创建包和接口" class="headerlink" title="创建包和接口"></a>创建包和接口</h3><p>创建client包<br>@FeignClient注解用于指定从哪个服务中调用功能 ，名称与被调用的服务名保持一致。<br>@GetMapping注解用于对被调用的微服务进行地址映射。</p><blockquote><p>@PathVariable注解一定要指定参数名称，否则出错<br>@Component注解防止，在其他位置注入CodClient时idea报错</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guli.edu.client;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;service-vod&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">VodClient</span> </span>&#123;</span><br><span class="line"><span class="meta">@DeleteMapping(value = &quot;/eduvod/vod/video/&#123;videoId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">removeVideo</span><span class="params">(<span class="meta">@PathVariable(&quot;videoId&quot;)</span> String videoId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用微服务"><a href="#调用微服务" class="headerlink" title="调用微服务"></a>调用微服务</h3><p>在调用端的VideoServiceImpl中调用client中的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeVideoById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询云端视频id</span></span><br><span class="line">    Video video = baseMapper.selectById(id);</span><br><span class="line">    String videoSourceId = video.getVideoSourceId();</span><br><span class="line">    <span class="comment">//删除视频资源</span></span><br><span class="line">    <span class="keyword">if</span>(!StringUtils.isEmpty(videoSourceId))&#123;</span><br><span class="line">        vodClient.removeVideo(videoSourceId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Integer result = baseMapper.deleteById(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> != result &amp;&amp; result &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 在线教育项目 </category>
          
          <category> Feign </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在线教育项目 </tag>
            
            <tag> Feign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务发现-搭建Nacos服务</title>
      <link href="/2021/10/07/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-%E6%90%AD%E5%BB%BANacos%E6%9C%8D%E5%8A%A1/"/>
      <url>/2021/10/07/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-%E6%90%AD%E5%BB%BANacos%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>（1）Nacos 是阿里巴巴推出来的一个新开源项目，是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p><p>（2）常见的注册中心：</p><ul><li><p>Eureka（原生，2.0遇到性能瓶颈，停止维护）</p></li><li><p>Zookeeper（支持，专业的独立产品。例如：dubbo）</p></li><li><p>Consul（原生，GO语言开发）</p></li><li><p>Nacos</p></li></ul><blockquote><p>相对于 Spring Cloud Eureka 来说，Nacos 更强大。Nacos = Spring Cloud Eureka + Spring Cloud Config ,Nacos 可以与 Spring, Spring Boot, Spring Cloud 集成，并能代替 Spring Cloud Eureka, Spring Cloud Config 通过 Nacos Server 和spring-cloud-starter-alibaba-nacos-discovery 实现服务的注册与发现。</p></blockquote><p>（3）Nacos是以服务为主要服务对象的中间件，Nacos支持所有主流的服务发现、配置和管理。<br>Nacos主要提供以下四大功能：</p><ul><li>服务发现和服务健康监测</li><li>动态配置服务</li><li>动态DNS服务</li><li>服务及其元数据管理</li></ul><h2 id="部署nacos"><a href="#部署nacos" class="headerlink" title="部署nacos"></a>部署nacos</h2><h3 id="下载地址和版本"><a href="#下载地址和版本" class="headerlink" title="下载地址和版本"></a>下载地址和版本</h3><p>下载地址：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a><br>下载版本：nacos-server-1.1.4.tar.gz或nacos-server-1.1.4.zip，解压任意目录即可</p><h3 id="启动nacos服务"><a href="#启动nacos服务" class="headerlink" title="启动nacos服务"></a>启动nacos服务</h3><ol><li>Linux/Unix/Mac<br>启动命令(standalone代表着单机模式运行，非集群模式)<br>启动命令：sh startup.sh -m standalone</li></ol><blockquote><p>期间在linux解压后，启动nacos服务,查看log日志，出现报错</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error: Could not find or load main class </span><br><span class="line">Caused by: java.lang.ClassNotFoundException: </span><br></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用JDK16</span><br><span class="line">在Nacos-Server的 bin / startup.sh</span><br><span class="line">由JAVA_OPT_EXT_FIX 配置引起启动报错</span><br><span class="line"></span><br><span class="line">在startup.sh文件中替换下方配置</span><br><span class="line"></span><br><span class="line">x JAVA_OPT_EXT_FIX=&quot;-Djava.ext.dirs=$&#123;JAVA_HOME&#125;/jre/lib/ext:$&#123;JAVA_HOME&#125;/lib/ext&quot;</span><br><span class="line">√ JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -Djava.ext.dirs=$&#123;JAVA_HOME&#125;/jre/lib/ext:$&#123;JAVA_HOME&#125;/lib/ext&quot;</span><br><span class="line"></span><br><span class="line">x echo &quot;$JAVA $JAVA_OPT_EXT_FIX $&#123;JAVA_OPT&#125;&quot;</span><br><span class="line">√ echo &quot;$JAVA $&#123;JAVA_OPT&#125;&quot;</span><br><span class="line"></span><br><span class="line">x echo &quot;$JAVA $JAVA_OPT_EXT_FIX $&#123;JAVA_OPT&#125;&quot; &gt; $&#123;BASE_DIR&#125;/logs/start.out 2&gt;&amp;1 &amp;</span><br><span class="line">x nohup &quot;$JAVA&quot; &quot;$JAVA_OPT_EXT_FIX&quot; $&#123;JAVA_OPT&#125; nacos.nacos &gt;&gt; $&#123;BASE_DIR&#125;/logs/start.out 2&gt;&amp;1 &amp;</span><br><span class="line">√ echo &quot;$JAVA $&#123;JAVA_OPT&#125;&quot; &gt; $&#123;BASE_DIR&#125;/logs/start.out 2&gt;&amp;1 &amp;</span><br><span class="line">√ nohup $JAVA $&#123;JAVA_OPT&#125; nacos.nacos &gt;&gt; $&#123;BASE_DIR&#125;/logs/start.out 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>解决完后，重新启动nacos服务，查看日志再次报错</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: No DataSource set</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在nacos的conf中找到application.properties，配置数据库</span><br><span class="line">spring.datasource.platform=mysql</span><br><span class="line"></span><br><span class="line">db.num=1</span><br><span class="line">db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=10000&amp;socketTimeout=30000&amp;autoReconnect=true</span><br><span class="line">db.user=root</span><br><span class="line">db.password=123456</span><br></pre></td></tr></table></figure><blockquote><p>启动成功后<br>访问：http://服务器ip:8848/nacos<br>用户名密码：nacos/nacos</p></blockquote><ol start="2"><li>Windows<br>启动命令：cmd startup.cmd 或者双击startup.cmd运行文件。<br>访问：<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a><br>用户名密码：nacos/nacos</li></ol><h2 id="服务注册（service-edu为例）"><a href="#服务注册（service-edu为例）" class="headerlink" title="服务注册（service_edu为例）"></a>服务注册（service_edu为例）</h2><p>把service-edu微服务注册到注册中心中，service-vod步骤相同</p><h3 id="引入依赖在service的pom文件中"><a href="#引入依赖在service的pom文件中" class="headerlink" title="引入依赖在service的pom文件中"></a>引入依赖在service的pom文件中</h3><p>配置Nacos客户端的pom依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--服务注册--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在要注册的服务的配置文件中-application进行配置Nacos地址"><a href="#在要注册的服务的配置文件中-application进行配置Nacos地址" class="headerlink" title="在要注册的服务的配置文件中 application进行配置Nacos地址"></a>在要注册的服务的配置文件中 application进行配置Nacos地址</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># nacos服务地址</span><br><span class="line">spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848</span><br></pre></td></tr></table></figure><h3 id="在启动类添加注解"><a href="#在启动类添加注解" class="headerlink" title="在启动类添加注解"></a>在启动类添加注解</h3><p>在客户端微服务启动类中添加注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">//nacos注解</span></span><br></pre></td></tr></table></figure><h3 id="启动客户端微服务"><a href="#启动客户端微服务" class="headerlink" title="启动客户端微服务"></a>启动客户端微服务</h3><p>启动注册中心<br>启动已注册的微服务，可以在Nacos服务列表中看到被注册的微服务</p>]]></content>
      
      
      <categories>
          
          <category> 在线教育项目 </category>
          
          <category> Nacos服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在线教育项目 </tag>
            
            <tag> Nacos服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务SpringCloud</title>
      <link href="/2021/10/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1SpringCloud/"/>
      <url>/2021/10/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1SpringCloud/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud相关概念介绍"><a href="#SpringCloud相关概念介绍" class="headerlink" title="SpringCloud相关概念介绍"></a>SpringCloud相关概念介绍</h1><h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务 *"></a>什么是微服务 *</h2><ul><li>微服务是架构风格</li><li>把一个项目拆分成独立的多个服务，多个服务是独立运行，每个服务占用独立进程</li></ul><h2 id="为什么需要微服务"><a href="#为什么需要微服务" class="headerlink" title="为什么需要微服务"></a>为什么需要微服务</h2><p>在传统的IT行业软件大多都是各种独立系统的堆砌，这些系统的问题总结来说就是扩展性差，可靠性不高，维护成本高。到后面引入了SOA服务化，但是，由于 SOA 早期均使用了总线模式，这种总线模式是与某种技术栈强绑定的，比如：J2EE。这导致很多企业的遗留系统很难对接，切换时间太长，成本太高，新系统稳定性的收敛也需要一些时间。 </p><h2 id="微服务与单体架构区别"><a href="#微服务与单体架构区别" class="headerlink" title="微服务与单体架构区别 *"></a>微服务与单体架构区别 *</h2><p>（1）单体架构所有的模块全都耦合在一块，代码量大，维护困难。</p><pre><code>     微服务每个模块就相当于一个单独的项目，代码量明显减少，遇到问题也相对来说比较好解决。</code></pre><p>（2）单体架构所有的模块都共用一个数据库，存储方式比较单一。</p><pre><code>     微服务每个模块都可以使用不同的存储方式（比如有的用redis，有的用mysql等），数据库也是单个模块对应自己的数据库。</code></pre><p>（3）单体架构所有的模块开发所使用的技术一样。</p><pre><code>     微服务每个模块都可以使用不同的开发技术，开发模式更灵活。 </code></pre><h2 id="微服务本质"><a href="#微服务本质" class="headerlink" title="微服务本质"></a>微服务本质</h2><p>（1）微服务，关键其实不仅仅是微服务本身，而是系统要提供一套基础的架构，这种架构使得微服务可以独立的部署、运行、升级，不仅如此，这个系统架构还让微服务与微服务之间在结构上“松耦合”，而在功能上则表现为一个统一的整体。这种所谓的“统一的整体”表现出来的是统一风格的界面，统一的权限管理，统一的安全策略，统一的上线过程，统一的日志和审计方法，统一的调度方式，统一的访问入口等等。<br>（2）微服务的目的是有效的拆分应用，实现敏捷开发和部署 。<br>（3）微服务提倡的理念团队间应该是 inter-operate, not integrate 。inter-operate是定义好系统的边界和接口，在一个团队内全栈，让团队自治，原因就是因为如果团队按照这样的方式组建，将沟通的成本维持在系统内部，每个子系统就会更加内聚，彼此的依赖耦合能变弱，跨系统的沟通成本也就能降低。</p><h2 id="什么样的项目适合微服务"><a href="#什么样的项目适合微服务" class="headerlink" title="什么样的项目适合微服务"></a>什么样的项目适合微服务</h2><p>微服务可以按照业务功能本身的独立性来划分，如果系统提供的业务是非常底层的，如：操作系统内核、存储系统、网络系统、数据库系统等等，这类系统都偏底层，功能和功能之间有着紧密的配合关系，如果强制拆分为较小的服务单元，会让集成工作量急剧上升，并且这种人为的切割无法带来业务上的真正的隔离，所以无法做到独立部署和运行，也就不适合做成微服务了。</p><h2 id="微服务开发框架"><a href="#微服务开发框架" class="headerlink" title="微服务开发框架"></a>微服务开发框架</h2><p>目前微服务的开发框架，最常用的有以下四个：</p><ul><li>Spring Cloud：<a href="http://projects.spring.io/spring-cloud%EF%BC%88%E7%8E%B0%E5%9C%A8%E9%9D%9E%E5%B8%B8%E6%B5%81%E8%A1%8C%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%EF%BC%89">http://projects.spring.io/spring-cloud（现在非常流行的微服务架构）</a></li><li>Dubbo：http：//dubbo.io</li><li>Dropwizard：<a href="http://www.dropwizard.io/">http://www.dropwizard.io</a> （关注单个微服务的开发）</li><li>Consul、etcd&amp;etc.（微服务的模块）</li></ul><h2 id="什么是SpringCloud"><a href="#什么是SpringCloud" class="headerlink" title="什么是SpringCloud"></a>什么是SpringCloud</h2><ul><li>SpringCloud并不是一种技术，是很多技术总称，很多框架集合</li><li>SpringCloud里面有很多框架(技术)，使用SpringCloud里面这些框架实现微服务操作</li><li>使用SpringCloud，需要依赖技术SpringBoot</li></ul><h2 id="SpringCloud和SpringBoot是什么关系"><a href="#SpringCloud和SpringBoot是什么关系" class="headerlink" title="SpringCloud和SpringBoot是什么关系"></a>SpringCloud和SpringBoot是什么关系</h2><p>Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务，Spring Cloud是一个基于Spring Boot实现的开发工具；Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架； Spring Boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud很大的一部分是基于Spring Boot来实现，必须基于Spring Boot开发。可以单独使用Spring Boot开发项目，但是Spring Cloud离不开 Spring Boot。</p><h2 id="Spring-Cloud相关基础服务组件"><a href="#Spring-Cloud相关基础服务组件" class="headerlink" title="Spring Cloud相关基础服务组件"></a>Spring Cloud相关基础服务组件</h2><p>服务发现——Netflix Eureka  <code>（Nacos）</code><br>服务调用——Netflix Feign<br>熔断器——Netflix Hystrix<br>服务网关——Spring Cloud  GateWay<br>分布式配置——Spring Cloud Config  <code>（Nacos）</code><br>消息总线 —— Spring Cloud Bus <code>（Nacos）</code></p><h2 id="Spring-Cloud的版本"><a href="#Spring-Cloud的版本" class="headerlink" title="Spring Cloud的版本"></a>Spring Cloud的版本</h2><p>Spring Cloud并没有熟悉的数字版本号，而是对应一个开发代号。</p><p>Cloud代号    Boot版本(train)    Boot版本(tested)    lifecycle<br>Angle           1.2.x    incompatible with 1.3    EOL in July 2017<br>Brixton           1.3.x             1.4.x            2017-07卒<br>Camden           1.4.x             1.5.x             -<br>Dalston           1.5.x    not expected 2.x         -<br>Edgware           1.5.x    not expected 2.x         -<br>Finchley       2.0.x    not expected 1.5.x          -<br>Greenwich      2.1.x<br>Hoxton         2.2.x    </p><p>开发代号看似没有什么规律，但实际上首字母是有顺序的，比如：Dalston版本，我们可以简称 D 版本，对应的 Edgware 版本我们可以简称 E 版本。</p><h2 id="小版本"><a href="#小版本" class="headerlink" title="小版本"></a>小版本</h2><p>Spring Cloud 小版本分为:</p><p>SNAPSHOT： 快照版本，随时可能修改</p><p>M： MileStone，M1表示第1个里程碑版本，一般同时标注PRE，表示预览版版。</p><p>SR： Service Release，SR1表示第1个正式版本，一般同时标注GA：(GenerallyAvailable),表示稳定版本。</p>]]></content>
      
      
      <categories>
          
          <category> 在线教育项目 </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在线教育项目 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云点播</title>
      <link href="/2021/09/28/%E9%98%BF%E9%87%8C%E4%BA%91%E7%82%B9%E6%92%AD/"/>
      <url>/2021/09/28/%E9%98%BF%E9%87%8C%E4%BA%91%E7%82%B9%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>开发场景：基于阿里云的云点播技术，实现上传、编辑、在线播放视频</p></blockquote><h2 id="开通阿里云点播"><a href="#开通阿里云点播" class="headerlink" title="开通阿里云点播"></a>开通阿里云点播</h2><p>搜索阿里云官网，搜素视频点播，开通服务(按量计费)。开启存储管理。</p><h2 id="SDK文档"><a href="#SDK文档" class="headerlink" title="SDK文档"></a>SDK文档</h2><p>查看服务端API、服务端SDK、上传SDK</p><blockquote><p>API: 阿里云提供固定的地址，只需要调用这个固定的地址，向地址传递参数、实现功能 (httpclient技术可以调用api地址)<br>SDK: sdk对api方法进行封装，更方便使用。之前使用EasyExcel调用调用阿里云提供类或则接口里面的方法是实现视频功能</p></blockquote><p>由于上传视频可以进行加密，加密之后，使用加密之后地址不能进行视频播放，在数据库存储不存地址，而是存储<strong>视频id</strong></p><h2 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h2><p>1.在service创建子模块serice_vod引入相关依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-vod<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.json<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>20170516<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.初始化操作，创建DefaultAcsClient对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DefaultAcsClient <span class="title">initVodClient</span><span class="params">(String accessKeyId, String accessKeySecret)</span> <span class="keyword">throws</span> ClientException </span>&#123;</span><br><span class="line">        String regionId = <span class="string">&quot;cn-shanghai&quot;</span>;  <span class="comment">// 点播服务接入区域</span></span><br><span class="line">        DefaultProfile profile = DefaultProfile.getProfile(regionId, accessKeyId, accessKeySecret);</span><br><span class="line">        DefaultAcsClient client = <span class="keyword">new</span> DefaultAcsClient(profile);</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="获取视频播放地址-根据视频id获取到"><a href="#获取视频播放地址-根据视频id获取到" class="headerlink" title="获取视频播放地址 (根据视频id获取到)"></a>获取视频播放地址 (根据视频id获取到)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 根据视频ID获取视频播放地址</span></span><br><span class="line">        <span class="comment">//创建初始化对象</span></span><br><span class="line">        DefaultAcsClient client = InitObject.initVodClient(<span class="string">&quot;************&quot;</span>, <span class="string">&quot;************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建获取视频地址request和response</span></span><br><span class="line">        GetPlayInfoRequest request = <span class="keyword">new</span> GetPlayInfoRequest();</span><br><span class="line">        GetPlayInfoResponse response = <span class="keyword">new</span> GetPlayInfoResponse();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向request对象里面设置视频id</span></span><br><span class="line">        request.setVideoId(<span class="string">&quot;e64d6b55f7194941bd94481dcfa1b5d5&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用初始化对象里面的方法，传递request，获取数据</span></span><br><span class="line">        response = client.getAcsResponse(request);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;GetPlayInfoResponse.PlayInfo&gt; playInfoList = response.getPlayInfoList();</span><br><span class="line">        <span class="comment">//播放地址</span></span><br><span class="line">        <span class="keyword">for</span> (GetPlayInfoResponse.PlayInfo playInfo : playInfoList) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;PlayInfo.PlayURL = &quot;</span> + playInfo.getPlayURL() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Base信息 视频名</span></span><br><span class="line">        System.out.print(<span class="string">&quot;VideoBase.Title = &quot;</span> + response.getVideoBase().getTitle() + <span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="获取视频播放凭证-根据视频id获取到视频播放凭证"><a href="#获取视频播放凭证-根据视频id获取到视频播放凭证" class="headerlink" title="获取视频播放凭证 (根据视频id获取到视频播放凭证)"></a>获取视频播放凭证 (根据视频id获取到视频播放凭证)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据视频id获取视频播放凭证</span></span><br><span class="line">        <span class="comment">//创建初始化对象</span></span><br><span class="line">        DefaultAcsClient client = InitObject.initVodClient(<span class="string">&quot;************&quot;</span>, <span class="string">&quot;************&quot;</span>);</span><br><span class="line">        <span class="comment">//创建获取视频凭证request和response</span></span><br><span class="line">        GetVideoPlayAuthRequest request = <span class="keyword">new</span> GetVideoPlayAuthRequest();</span><br><span class="line">        GetVideoPlayAuthResponse response = <span class="keyword">new</span> GetVideoPlayAuthResponse();</span><br><span class="line">        <span class="comment">//向request设置视频id</span></span><br><span class="line">        request.setVideoId(<span class="string">&quot;e64d6b55f7194941bd94481dcfa1b5d5&quot;</span>);</span><br><span class="line">        <span class="comment">//调用初始化对象的方法得到凭证</span></span><br><span class="line">        response = client.getAcsResponse(request);</span><br><span class="line">        System.out.println(<span class="string">&quot;playauth:&quot;</span>+response.getPlayAuth());</span><br></pre></td></tr></table></figure><h2 id="上传视频到阿里云视频点播服务"><a href="#上传视频到阿里云视频点播服务" class="headerlink" title="上传视频到阿里云视频点播服务"></a>上传视频到阿里云视频点播服务</h2><blockquote><p>由于aliyun-sdk-vod-upload没有开源，所以不能直接在pom文件中直接引用依赖。<br><strong>解决：</strong>将依赖安装在本地maven仓库</p></blockquote><ol><li>去官网下载 测试样例aliyun,网址:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://help.aliyun.com/document_detail/51992.html?spm=a2c4g.11186623.6.1029.2dab6cecZfMGvO</span><br></pre></td></tr></table></figure></li><li>将测试样例解压，进入lib目录下，在命令行执行下面的命令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -DgroupId=com.aliyun -DartifactId=aliyun-java-vod-upload -Dversion=1.4.11 -Dpackaging=jar -Dfile=aliyun-java-vod-upload-1.4.11.jar</span><br></pre></td></tr></table></figure><blockquote><p>==在这个命令中,我在网上看到的都是错的,很搞笑的错误,多注意下面的对应关系==</p></blockquote></li></ol><ul><li><p>DgroupId 对应 — &lt; groupId &gt;</p></li><li><p>DartifactId 对应 – &lt; artifactId &gt;</p></li><li><p>Dversion 对应 – &lt; version &gt;</p></li><li><p>Dfile 对应jar包在你电脑上的路径</p></li></ul><p><strong>其次你必须配置好maven的环境变量不然无法运行该命令(会安装到maven设置好的本地仓库中)</strong></p><ol start="3"><li><p>pom文件引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-vod-upload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>上传视频</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//上传视频的方法</span></span><br><span class="line">        String accessKeyId=<span class="string">&quot;************&quot;</span>;</span><br><span class="line">        String accessKeySecret=<span class="string">&quot;************&quot;</span>;</span><br><span class="line">        String title=<span class="string">&quot;3 - How Does Project Submission Work - upload by sdk&quot;</span>; <span class="comment">//上传之后文件名称</span></span><br><span class="line">        String fileName=<span class="string">&quot;F:\\java\\课件笔记源码资料\\1_课件\\在线教育平台\\谷里\\项目资料\\1-阿里云上传测试视频\\6 - What If I Want to Move Faster.mp4&quot;</span>; <span class="comment">//本地文件路径和名称</span></span><br><span class="line">        UploadVideoRequest request = <span class="keyword">new</span> UploadVideoRequest(accessKeyId, accessKeySecret, title, fileName);</span><br><span class="line">        <span class="comment">/* 可指定分片上传时每个分片的大小，默认为2M字节 */</span></span><br><span class="line">        request.setPartSize(<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024L</span>);</span><br><span class="line">        <span class="comment">/* 可指定分片上传时的并发线程数，默认为1，(注：该配置会占用服务器CPU资源，需根据服务器情况指定）*/</span></span><br><span class="line">        request.setTaskNum(<span class="number">1</span>);</span><br><span class="line">        UploadVideoImpl uploader = <span class="keyword">new</span> UploadVideoImpl();</span><br><span class="line">        UploadVideoResponse response = uploader.uploadVideo(request);</span><br><span class="line">        System.out.print(<span class="string">&quot;RequestId=&quot;</span> + response.getRequestId() + <span class="string">&quot;\n&quot;</span>);  <span class="comment">//请求视频点播服务的请求ID</span></span><br><span class="line">        <span class="keyword">if</span> (response.isSuccess()) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;VideoId=&quot;</span> + response.getVideoId() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 如果设置回调URL无效，不影响视频上传，可以返回VideoId同时会返回错误码。其他情况上传失败时，VideoId为空，此时需要根据返回错误码分析具体错误原因 */</span></span><br><span class="line">            System.out.print(<span class="string">&quot;VideoId=&quot;</span> + response.getVideoId() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;ErrorCode=&quot;</span> + response.getCode() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;ErrorMessage=&quot;</span> + response.getMessage() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="删除阿里云点播视频"><a href="#删除阿里云点播视频" class="headerlink" title="删除阿里云点播视频"></a>删除阿里云点播视频</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建初始化对象</span></span><br><span class="line">        DefaultAcsClient client = InitObject.initVodClient(<span class="string">&quot;********&quot;</span>, <span class="string">&quot;********&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建删除视频的request和response</span></span><br><span class="line">        DeleteVideoRequest request = <span class="keyword">new</span> DeleteVideoRequest();</span><br><span class="line">        DeleteVideoResponse response = <span class="keyword">new</span> DeleteVideoResponse();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//支持传入多个视频ID，多个用逗号分隔</span></span><br><span class="line">        <span class="comment">//request.setVideoIds(&quot;VideoId1,VideoId2&quot;);</span></span><br><span class="line">        request.setVideoIds(<span class="string">&quot;e64d6b55f7194941bd94481dcfa1b5d5&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用初始化对象里面的方法，传递request，获取数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response = client.getAcsResponse(request);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;ErrorMessage = &quot;</span> + e.getLocalizedMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;RequestId = &quot;</span> + response.getRequestId() + <span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="视频点播微服务的创建-实践"><a href="#视频点播微服务的创建-实践" class="headerlink" title="视频点播微服务的创建(实践)"></a>视频点播微服务的创建(实践)</h2><h3 id="创建微服务模块"><a href="#创建微服务模块" class="headerlink" title="创建微服务模块"></a>创建微服务模块</h3><p>Artifact：service-vod</p><h3 id="pom文件引入依赖"><a href="#pom文件引入依赖" class="headerlink" title="pom文件引入依赖"></a>pom文件引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-vod<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-vod-upload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.json<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 服务端口</span><br><span class="line">server.port=8003</span><br><span class="line"># 服务名</span><br><span class="line">spring.application.name=service-vod</span><br><span class="line"></span><br><span class="line"># 环境设置：dev、test、prod</span><br><span class="line">spring.profiles.active=dev</span><br><span class="line"></span><br><span class="line">#阿里云 vod</span><br><span class="line">#不同的服务器，地址不同</span><br><span class="line">aliyun.vod.file.keyid=your accessKeyId</span><br><span class="line">aliyun.vod.file.keysecret=your accessKeySecret</span><br><span class="line"></span><br><span class="line"># 最大上传单个文件大小：默认1M</span><br><span class="line">spring.servlet.multipart.max-file-size=1024MB</span><br><span class="line"># 最大置总上传的数据大小 ：默认10M</span><br><span class="line">spring.servlet.multipart.max-request-size=1024MB</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建启动类"><a href="#创建启动类" class="headerlink" title="创建启动类"></a>创建启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.zzf&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceVodApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ServiceVodApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建ConstantVodUtils"><a href="#创建ConstantVodUtils" class="headerlink" title="创建ConstantVodUtils"></a>创建ConstantVodUtils</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当项目已启动，spring接口，spring加载之后，执行接口一个方法</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantVodUtils</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取配置文件内容</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.vod.file.keyid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.vod.file.keysecret&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义公开静态常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String ACCESS_KEY_ID;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String ACCESS_KEY_SECRET;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在Spring容器加载完上面的属性之后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ACCESS_KEY_ID = accessKeyId;</span><br><span class="line">        ACCESS_KEY_SECRET = accessKeySecret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上传视频应用"><a href="#上传视频应用" class="headerlink" title="上传视频应用"></a>上传视频应用</h3><blockquote><p>创建Controller、Serivce层，此处主要记录serviceImpl的内容</p></blockquote><ol><li>后端代码实现<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//上传视频到阿里云</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadAlyVideo</span><span class="params">(MultipartFile file)</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//accessKeyId, accessKeySecret,</span></span><br><span class="line">            <span class="comment">// title：上传之后显示名称   获取文件名字（去掉文件格式名字 .mp4）</span></span><br><span class="line">            String originalFilename = file.getOriginalFilename();</span><br><span class="line">            <span class="comment">//lastIndexOf(String str) 获取某字符串起始索引</span></span><br><span class="line">            String title = originalFilename.substring(<span class="number">0</span>,originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// fileName：上传文件原始名称</span></span><br><span class="line">            <span class="comment">// 01.MP4</span></span><br><span class="line">            String fileName = file.getOriginalFilename();</span><br><span class="line">            <span class="comment">// inputStream：上传文件输入流</span></span><br><span class="line">            InputStream inputStream = file.getInputStream();</span><br><span class="line"></span><br><span class="line">            UploadStreamRequest request = <span class="keyword">new</span> UploadStreamRequest(ConstantVodUtils.ACCESS_KEY_ID, ConstantVodUtils.ACCESS_KEY_SECRET, title, fileName, inputStream);</span><br><span class="line">            UploadVideoImpl uploader = <span class="keyword">new</span> UploadVideoImpl();</span><br><span class="line">            UploadStreamResponse response = uploader.uploadStream(request);</span><br><span class="line"></span><br><span class="line">            String videoId = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (response.isSuccess()) &#123;</span><br><span class="line">                videoId = response.getVideoId();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果设置回调URL无效，不影响视频上传，可以返回VideoId同时会返回错误码。其他情况上传失败时，VideoId为空，此时需要根据返回错误码分析具体错误原因</span></span><br><span class="line">                videoId = response.getVideoId();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> videoId;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>前端实现</li></ol><ul><li><p>整合上传组件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;上传视频&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-upload</span></span></span><br><span class="line"><span class="tag">           <span class="attr">:on-success</span>=<span class="string">&quot;handleVodUploadSuccess&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">:on-remove</span>=<span class="string">&quot;handleVodRemove&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">:before-remove</span>=<span class="string">&quot;beforeVodRemove&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">:on-exceed</span>=<span class="string">&quot;handleUploadExceed&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">:file-list</span>=<span class="string">&quot;fileList&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">:action</span>=<span class="string">&quot;BASE_API+&#x27;/admin/vod/video/upload&#x27;&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">:limit</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">class</span>=<span class="string">&quot;upload-demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>上传视频<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-tooltip</span> <span class="attr">placement</span>=<span class="string">&quot;right-end&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">&quot;content&quot;</span>&gt;</span>最大支持1G，<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            支持3GP、ASF、AVI、DAT、DV、FLV、F4V、<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            GIF、M2T、M4V、MJ2、MJPEG、MKV、MOV、MP4、<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            MPE、MPG、MPEG、MTS、OGG、QT、RM、RMVB、<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            SWF、TS、VOB、WMV、WEBM 等视频格式上传<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;el-icon-question&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-tooltip</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-upload</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>数据定义</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fileList: [],<span class="comment">//上传文件列表</span></span><br><span class="line"><span class="attr">BASE_API</span>: process.env.BASE_API <span class="comment">// 接口API地址</span></span><br></pre></td></tr></table></figure></li><li><p>配置nginx反向代理<br>将接口地址加入nginx配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location ~ /vod/ &#123;           </span><br><span class="line">    proxy_pass http://localhost:8003;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>配置nginx上传文件大小，否则上传时会有 413 (Request Entity Too Large) 异常<br>打开nginx主配置文件nginx.conf，找到http{}，添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client_max_body_size 1024m;</span><br></pre></td></tr></table></figure><p>重启nginx</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="删除视频应用"><a href="#删除视频应用" class="headerlink" title="删除视频应用"></a>删除视频应用</h3><ol><li>后端接口</li></ol><ul><li><p>初始化DefaultAcsClient</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitVodClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DefaultAcsClient <span class="title">initVodClient</span><span class="params">(String accessKeyId, String accessKeySecret)</span>  </span>&#123;</span><br><span class="line">        String regionId = <span class="string">&quot;cn-shanghai&quot;</span>;  <span class="comment">// 点播服务接入区域</span></span><br><span class="line">        DefaultProfile profile = DefaultProfile.getProfile(regionId, accessKeyId, accessKeySecret);</span><br><span class="line">        DefaultAcsClient client = <span class="keyword">new</span> DefaultAcsClient(profile);</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据视频id删除阿里云视频</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据视频id删除阿里云视频</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;removeAlyVideo/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">removeAlyVideo</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//初始化对象</span></span><br><span class="line">            DefaultAcsClient client = InitVodClient.initVodClient(ConstantVodUtils.ACCESS_KEY_ID, ConstantVodUtils.ACCESS_KEY_SECRET);</span><br><span class="line">            <span class="comment">//创建删除视频request对象</span></span><br><span class="line">            DeleteVideoRequest request = <span class="keyword">new</span> DeleteVideoRequest();</span><br><span class="line">            <span class="comment">//向request设置视频id</span></span><br><span class="line">            request.setVideoIds(id);</span><br><span class="line">            <span class="comment">//调用初始化对象的方法实现删除</span></span><br><span class="line">            client.getAcsResponse(request);</span><br><span class="line">            <span class="keyword">return</span> R.ok();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GuliException(<span class="number">20001</span>,<span class="string">&quot;删除视频失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>前端实现</li></ol><ul><li><p>video.js 代码实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除视频</span></span><br><span class="line">    <span class="function"><span class="title">deleteAliyunvod</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request(&#123;</span><br><span class="line">            <span class="attr">url</span>:<span class="string">`/eduvod/video/removeAlyVideo/<span class="subst">$&#123;id&#125;</span>`</span>,</span><br><span class="line">            <span class="attr">method</span>:<span class="string">&quot;delete&quot;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></li><li><p>页面调用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点击确定调用的方法</span></span><br><span class="line"><span class="function"><span class="title">handleVodRemove</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//调用接口的删除视频的方法</span></span><br><span class="line">    video.deleteAliyunvod(<span class="built_in">this</span>.video.videoSourceId)</span><br><span class="line">        .then(<span class="function"><span class="params">reponse</span> =&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//提示信息</span></span><br><span class="line">                <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">                <span class="attr">message</span>: <span class="string">&#x27;删除视频成功!&#x27;</span></span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//把文件列表清空</span></span><br><span class="line">                <span class="built_in">this</span>.fileList = []</span><br><span class="line">                <span class="comment">//把video视频id和视频名称值清空</span></span><br><span class="line">                <span class="comment">//上传视频id赋值</span></span><br><span class="line">                <span class="built_in">this</span>.video.videoSourceId = <span class="string">&#x27;&#x27;</span> </span><br><span class="line">                <span class="comment">//上传视频名称赋值</span></span><br><span class="line">                <span class="built_in">this</span>.video.videoOriginalName = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//点击x调用这个方法</span></span><br><span class="line"><span class="function"><span class="title">beforeVodRemove</span>(<span class="params">file,fileList</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$confirm(<span class="string">`确定移除<span class="subst">$&#123;file.name&#125;</span>?`</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 在线教育项目 </category>
          
          <category> 阿里云服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在线教育项目 </tag>
            
            <tag> 阿里云服务 </tag>
            
            <tag> 阿里云点播 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调用接口，报错没找到某某mapper接口方法</title>
      <link href="/2021/09/25/%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%8C%E6%8A%A5%E9%94%99%E6%B2%A1%E6%89%BE%E5%88%B0%E6%9F%90%E6%9F%90%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95/"/>
      <url>/2021/09/25/%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%8C%E6%8A%A5%E9%94%99%E6%B2%A1%E6%89%BE%E5%88%B0%E6%9F%90%E6%9F%90%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：我们常常对数据库进行操作都需要通过mapper接口写相关方法，然后在相应的xml文件中写sql语句。在在线教育实践项目中发现了一个异常<code>Invalid bound statement (not found): com.zzf.eduservice.mapper.EduCourseMapper.getPublishCourseInfo</code><br>以下有几种方法解决</p></blockquote><h2 id="检查报错的方法名是否错误"><a href="#检查报错的方法名是否错误" class="headerlink" title="检查报错的方法名是否错误"></a>检查报错的方法名是否错误</h2><blockquote><p>由于有可能是maven默认加载机制造成的问题，maven加载时候，把java文件进行编译，如果其他类型文件，则不会加载</p></blockquote><h2 id="复制xml到target目录中"><a href="#复制xml到target目录中" class="headerlink" title="复制xml到target目录中"></a>复制xml到target目录中</h2><h2 id="把xml文件放到resource目录中"><a href="#把xml文件放到resource目录中" class="headerlink" title="把xml文件放到resource目录中"></a>把xml文件放到resource目录中</h2><h2 id="推荐使用：通过配置实现"><a href="#推荐使用：通过配置实现" class="headerlink" title="推荐使用：通过配置实现"></a>推荐使用：通过配置实现</h2><h3 id="1-pom-xml"><a href="#1-pom-xml" class="headerlink" title="1 pom.xml"></a>1 pom.xml</h3><p>在项目中的pom中配置如下节点</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 项目打包时会将java目录中的*.xml文件也进行打包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-项目application-properties"><a href="#2-项目application-properties" class="headerlink" title="2 项目application.properties"></a>2 项目application.properties</h3><p>在SpringBoot配置文件中添加配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置mapper xml文件的路径</span></span><br><span class="line"><span class="string">mybatis-plus.mapper-locations=classpath:com/guli/edu/mapper/xml/*.xml</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随手记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手记 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多表连接查询</title>
      <link href="/2021/09/25/%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/"/>
      <url>/2021/09/25/%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：在写在线教育项目中，回顾sql中的多表查询。本章节主要是通过学习大佬<a href="https://blog.csdn.net/zt15732625878/article/details/79074123">奔跑的大白啊</a>，在此作为学习记录笔记。</p></blockquote><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>连接查询主要分为3种：内连接、外连接、交叉连接</p><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p>使用比较运算符（包括=、&gt;、&lt;、&lt;&gt;、&gt;=、&lt;=、!&gt; 和!&lt;）进行表间的比较操作，查询与连接条件相匹配的数据。根据所使用的比较方式不同，内连接分为等值连接、自然连接和自连接三种。<br>关键字      <code>INNER JOIN</code></p><h3 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h3><p>使用”=”关系将表连接起来的查询，其查询结果中列出被连接表中的所有列，包括其中的重复列</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    PM_ACT_JOB_RLS.<span class="operator">*</span>, PM_ACT_RLS.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    PM_ACT_JOB_RLS</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> PM_ACT_RLS <span class="keyword">ON</span> PM_ACT_JOB_RLS.RlsPK <span class="operator">=</span> PM_ACT_RLS.RlsPK</span><br></pre></td></tr></table></figure><h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><p>等值连接中去掉重复的列，形成的连接</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    PM_ACT_JOB_RLS.JobPK,</span><br><span class="line">    PM_ACT_RLS.RlsPK,</span><br><span class="line">    RlsName</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    PM_ACT_JOB_RLS</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> PM_ACT_RLS <span class="keyword">ON</span> PM_ACT_JOB_RLS.RlsPK <span class="operator">=</span> PM_ACT_RLS.RlsPK</span><br></pre></td></tr></table></figure><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>如果在一个连接查询中，设计到的两个表都是同一个表，这种查询称为自连接查询。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--c1、c2逻辑上是两张表，物理上是一张表</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    c1.CategoryID,</span><br><span class="line">    c1.CategoryName</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    [dbo].[Category] c1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> [dbo].[Category] c2 <span class="keyword">ON</span> c1.[CategoryID] <span class="operator">=</span> c2.[ParentID]</span><br></pre></td></tr></table></figure><h2 id="内连接-1"><a href="#内连接-1" class="headerlink" title="内连接"></a>内连接</h2><p>内连接只返回满足连接条件的数据行，外连接不只列出与连接条件相匹配的行，而是列出左表（左外连接时）、右表（右外连接时）或两个表（全外连接时）中所有符合搜索条件的数据行。外连接分为左外连接、右外链接、全外连接三种</p><h3 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--左外连接  --1679条数据</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    me.<span class="operator">*</span>,</span><br><span class="line">    mo.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    MM_LOTS_EXT <span class="keyword">AS</span> me</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> MM_LOT_OPERATIONS <span class="keyword">AS</span> mo <span class="keyword">ON</span> me.LotID <span class="operator">=</span> mo.SerialNumber</span><br></pre></td></tr></table></figure><h3 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h3><p>返回右表中的所有行，如果右表中行在左表中没有匹配行，则在左表中相关字段返回NULL值。<br>关键字     <code>RIGHT [OUTER] JOIN</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--右外连接  --209条数据</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    me.<span class="operator">*</span>,</span><br><span class="line">    mo.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    MM_LOTS_EXT <span class="keyword">AS</span> me</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> MM_LOT_OPERATIONS <span class="keyword">AS</span> mo <span class="keyword">ON</span> me.LotID <span class="operator">=</span> mo.SerialNumber</span><br></pre></td></tr></table></figure><h3 id="全外连接-完全外连接"><a href="#全外连接-完全外连接" class="headerlink" title="全外连接/完全外连接"></a>全外连接/完全外连接</h3><p>返回两个连接中所有的记录数据，是左外连接和右外连接的并集。<br>关键字     <code>FULL [OUTER] JOIN</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--全外连接  --1816条数据 </span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    me.<span class="operator">*</span>,</span><br><span class="line">    mo.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    MM_LOTS_EXT <span class="keyword">AS</span> me</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> MM_LOT_OPERATIONS <span class="keyword">AS</span> mo <span class="keyword">ON</span> me.LotID <span class="operator">=</span> mo.SerialNumber</span><br></pre></td></tr></table></figure><h2 id="交叉连接-笛卡尔积"><a href="#交叉连接-笛卡尔积" class="headerlink" title="交叉连接/笛卡尔积"></a>交叉连接/笛卡尔积</h2><p>两个表做笛卡尔积，得到的结果集的行数是两个表的行数的乘积。<br>关键字      <code>CROSS JOIN</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--笛卡尔积 (cross join后加条件只能用where,不能用on)  --45条数据（9*5）</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    PM_ACT_JOB_RLS</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> PM_ACT_RLS</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>带有where条件的子句，往往会先生成两个表行数乘积的数据表，然后从根据where条件从中选择。<br>当数据量比价大的时候，笛卡尔积操作会很消耗数据库的性能</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随手记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手记 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>下拉框以及复选框</title>
      <link href="/2021/09/23/%E4%B8%8B%E6%8B%89%E6%A1%86%E4%BB%A5%E5%8F%8A%E5%A4%8D%E9%80%89%E6%A1%86/"/>
      <url>/2021/09/23/%E4%B8%8B%E6%8B%89%E6%A1%86%E4%BB%A5%E5%8F%8A%E5%A4%8D%E9%80%89%E6%A1%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>根据存储id和分类所有id进行比较，如果比较相同，让相同值进行数据回显</p></blockquote><h2 id="下拉列表"><a href="#下拉列表" class="headerlink" title="下拉列表"></a>下拉列表</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">&quot;selected&quot;</span>&gt;</span>前端开发<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">checked</span>/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>403状态码</title>
      <link href="/2021/09/23/403%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/2021/09/23/403%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>我们在开发中时常见到各种http状态码，那么403状态代表着什么呢？</p></blockquote><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>可以检查代码有没有添加跨域注解<code>@CrossOrigin</code></p><h2 id="路径写错了"><a href="#路径写错了" class="headerlink" title="路径写错了"></a>路径写错了</h2>]]></content>
      
      
      <categories>
          
          <category> http状态码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http状态码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主键策略</title>
      <link href="/2021/09/14/%E4%B8%BB%E9%94%AE%E7%AD%96%E7%95%A5/"/>
      <url>/2021/09/14/%E4%B8%BB%E9%94%AE%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们常常都会对数据库表中的id进行自增或则随机生成，那么在我们日常开发中有3种常见的主键策略</p></blockquote><h2 id="自动增长"><a href="#自动增长" class="headerlink" title="自动增长"></a>自动增长</h2><p>即我们常见的数据库表设计中，将id值设成AUTO INCREMENT</p><h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p>每次生成随机唯一的值，但<strong>排序不方便</strong></p><h2 id="redis实现"><a href="#redis实现" class="headerlink" title="redis实现"></a>redis实现</h2><h2 id="mp-MybatisPlus-自带策略-snowflake算法"><a href="#mp-MybatisPlus-自带策略-snowflake算法" class="headerlink" title="mp(MybatisPlus)自带策略 snowflake算法"></a>mp(MybatisPlus)自带策略 snowflake算法</h2><ul><li><code>IdType</code>是一个枚举类，定义了生成ID的类型</li><li><code>AUTO</code> 数据库ID自增</li><li><code>INPUT</code> 用户输入ID</li><li><code>ID_WORKER</code> 全局唯一ID，Long类型的主键</li><li><code>ID_WORKER_STR</code> 字符串全局唯一ID</li><li><code>UUID</code> 全局唯一ID，UUID类型的主键</li><li><code>NONE</code> 该类型为未设置主键类型</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line"><span class="keyword">private</span> Long Id;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随手记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MybaitsPlus </tag>
            
            <tag> 随手记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于ArrayList中的add()方法</title>
      <link href="/2021/09/10/%E5%85%B3%E4%BA%8EArrayList%E4%B8%AD%E7%9A%84add-%E6%96%B9%E6%B3%95/"/>
      <url>/2021/09/10/%E5%85%B3%E4%BA%8EArrayList%E4%B8%AD%E7%9A%84add-%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本章是参考CSDN博主<a href="https://blog.csdn.net/wang873985264/article/details/83411842">三木来啦</a>，以下为学习笔记。</p></blockquote><h2 id="关于ArrayList的add-方法"><a href="#关于ArrayList的add-方法" class="headerlink" title="关于ArrayList的add()方法"></a>关于ArrayList的add()方法</h2><p>源码位置：java.util.ArrayList：454行到462行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>以上代码倒数第二行可以看出，每次的add方法只会将引用地址放入集合中，并不会new新的对象，所以：</p><p>在一次add后，如果立即修改add的对象，并重新add，会将上一次的add对象也改变；<br>在循环中使用add方法尤其需要注意；<br>如果业务逻辑导致，可以在循环中每次add时，新创建一个对象，然后将原对象手动赋值到新对象，将新对象添加到集合中。</p>]]></content>
      
      
      <categories>
          
          <category> 在线教育项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手记 </tag>
            
            <tag> 在线教育项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速实现对象之间数据传递</title>
      <link href="/2021/09/09/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
      <url>/2021/09/09/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<h2 id="对象之间数据传递"><a href="#对象之间数据传递" class="headerlink" title="对象之间数据传递"></a>对象之间数据传递</h2><blockquote><p>前言，在我们常规的开发中，经常会将对象之间的数据进行传递或则交换，使用频繁的<code>get</code>、<code>set</code>方法。如果想减少这种冗余的代码重复出现，可以使用Spring中的<code>BeanUtils</code>下的<code>copyProperties(Object source,Object target)</code>方法</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 普通写法  将eduSubject的内容提取出来后赋值给oneSubject</span></span><br><span class="line">oneSubject.setId(eduSubject.getId());</span><br><span class="line">oneSubject.setTitle(eduSubject.getTitle());</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 使用工具类 Spring中的BeanUtils.copyProperties(数据源对象,目标对象)   【变量名和数据类型要相同才能传递数据】</span></span><br><span class="line">BeanUtils.copyProperties(eduSubject,oneSubject);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>PS：</strong><code>BeanUtils</code>所花费的时间要超过取数据、将其复制到对应的 value对象（通过手动调用<code>get</code>和<code>set</code>方法），以及通过串行化将其返回到远程的客户机的时间总和。所以要小心使用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 在线教育项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手记 </tag>
            
            <tag> 在线教育项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue知识点</title>
      <link href="/2021/09/08/vue%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2021/09/08/vue%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="script中data的2种写法"><a href="#script中data的2种写法" class="headerlink" title="script中data的2种写法"></a>script中data的2种写法</h2><blockquote><p>vue中，在script中data有2种写法。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.使用return</span></span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取路由的id值"><a href="#获取路由的id值" class="headerlink" title="获取路由的id值"></a>获取路由的id值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取路由的id值【ps：id即是浏览器的参数,不要改成跟url中的占位名称】</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.$route.params &amp;&amp; <span class="built_in">this</span>.$route.params.id)&#123;</span><br><span class="line">        <span class="built_in">this</span>.$route.params.id</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$router.push(&#123;<span class="attr">path</span>:<span class="string">&#x27;uri地址&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="路由跳转重复页面"><a href="#路由跳转重复页面" class="headerlink" title="路由跳转重复页面"></a>路由跳转重复页面</h2><blockquote><p>由于多次路由跳转到同一个页面，在页面中<code>cretaed</code>方法只会执行第一次，后面再进行跳转不会执行的。所以需要一个<code>watch</code>监听路由变化</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">watch:&#123; <span class="comment">//监听</span></span><br><span class="line">    $route(to,form)&#123; <span class="comment">//路由变化方式，路由发生变化，方法方法执行</span></span><br><span class="line">      <span class="built_in">this</span>.init()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 在线教育项目 </category>
          
          <category> 前端知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在线教育项目 </tag>
            
            <tag> vue知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2021/09/07/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/09/07/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1.面向对象和面向过程的区别"></a>1.面向对象和面向过程的区别</h2><ul><li><strong>面向过程 ：面向过程性能比面向对象高。</strong> 因为类调⽤时需要实例化，开销⽐较⼤，⽐较消耗资源，所以当性能是最重要的考量因素的时候，⽐如单⽚机、嵌⼊式开发、Linux/Unix 等<br>⼀般采⽤⾯向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展</strong>。</li><li><strong>面向对象 ：面向对象易维护、易复用、易扩展。</strong> 因为⾯向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能⽐面向过程低</strong>。</li></ul><p>参⻅ issue : <a href="https://github.com/Snailclimb/JavaGuide/issues/431">面向过程 ：面向过程性能⽐面向对象⾼？？</a></p><blockquote><p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原<br>因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直<br>接被 CPU 执行的二进制机械码。<br>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它⼀些面向过程的脚本语<br>言性能也并不⼀定比 Java 好。</p></blockquote><h2 id="2-Java语言有哪些特点"><a href="#2-Java语言有哪些特点" class="headerlink" title="2.Java语言有哪些特点?"></a>2.Java语言有哪些特点?</h2><ol><li>简单易学；</li><li>⾯向对象（封装，继承，多态）；</li><li>平台⽆关性（ Java 虚拟机实现平台⽆关性）；</li><li>可靠性；</li><li>安全性；</li><li>⽀持多线程（Java 语⾔提供了多线程⽀持，C++11 开始（2011 年的时候）,C++就引⼊了多线程库，在windows、linux、macos 都可以使⽤ std::thread 和 std::async 来创建线程。）；</li><li>⽀持⽹络编程并且很⽅便（ Java 语⾔诞⽣本身就是为简化⽹络编程设计的，因此 Java 语⾔不仅⽀持⽹络编程⽽且很⽅便）；</li><li>编译与解释并存；</li></ol><h2 id="3-关于JVM、JDK和JRE最详细通俗的解答"><a href="#3-关于JVM、JDK和JRE最详细通俗的解答" class="headerlink" title="3.关于JVM、JDK和JRE最详细通俗的解答"></a>3.关于JVM、JDK和JRE最详细通俗的解答</h2><h3 id="1-JVM"><a href="#1-JVM" class="headerlink" title="1.JVM"></a>1.JVM</h3><p>Java虚拟机（JVM）是运⾏ Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），⽬的是使⽤相同的字节码，它们都会给出相同的结果。<br><strong>什么是字节码?采用字节码的好处是什么?</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试笔记 </tag>
            
            <tag> Java核心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何将本地代码上传到指定仓库</title>
      <link href="/2021/09/06/%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%8C%87%E5%AE%9A%E4%BB%93%E5%BA%93/"/>
      <url>/2021/09/06/%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%8C%87%E5%AE%9A%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在实际工作或则学习过程中，使用远程仓库保存代码是一件十分常见的事情。本文使用参考网上教程，记录怎么将本地已有项目上传到远程仓库中。</p></blockquote><p>最简单的方式：先在远程仓库中创建新的仓库，然后通过git命令<code>git clone ....</code>,然后将已有的代码复制到克隆下来的文件夹中，然后再通过git命令<code>git push ...</code>或则工具上传。</p><p><strong>接下来是通过命令将本地代码上传到远程仓库中</strong></p><h3 id="上传步骤"><a href="#上传步骤" class="headerlink" title="上传步骤"></a>上传步骤</h3><ul><li>进入到项目文件架，右键打开<code>Git Bash Here</code>命令，进入git命令操作界面</li><li><code>git init</code></li><li><code>git add .</code></li><li><code>git commit -m &quot;创建项目&quot;</code></li><li><code>git remote add origin xxxx</code> <strong>关键步骤，将本地仓库和远程仓库关联</strong></li><li><code>git push -u origin master</code>:将代码push到远程</li></ul><p>自此，本地代码已经提交到远程仓库中~</p>]]></content>
      
      
      <categories>
          
          <category> git命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus添加一条记录后怎么获取Id</title>
      <link href="/2021/09/03/MybatisPlus%E6%B7%BB%E5%8A%A0%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E5%90%8E%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96Id/"/>
      <url>/2021/09/03/MybatisPlus%E6%B7%BB%E5%8A%A0%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E5%90%8E%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96Id/</url>
      
        <content type="html"><![CDATA[<blockquote><p>MybatisPlus在执行了添加语句以后，传入的要保存的对象因为是引用类型就被设置了Id，所以后面直接通过getId()获取Id即可。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随手记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MybaitsPlus </tag>
            
            <tag> 随手记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iptables和firewall防火墙总结</title>
      <link href="/2021/09/02/iptables%E5%92%8Cfirewall%E9%98%B2%E7%81%AB%E5%A2%99%E6%80%BB%E7%BB%93/"/>
      <url>/2021/09/02/iptables%E5%92%8Cfirewall%E9%98%B2%E7%81%AB%E5%A2%99%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>暂时偷懒，可以先参考<a href="https://www.cnblogs.com/wdp-home/p/11651855.html">白牛王子</a>学习，后续会进行更新。</p></blockquote><blockquote><p>linux防火墙查看状态<a href="https://www.cnblogs.com/zxg-blog/p/9835263.html">firewall、iptable命令总结</a></p></blockquote><blockquote><p><a href="https://ipcmen.com/firewall-cmd">Linux命令大全(手册)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 防火墙学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos7 </tag>
            
            <tag> 小白 </tag>
            
            <tag> 防火墙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7 搭建PPTP-VPN</title>
      <link href="/2021/09/02/Centos7-%E6%90%AD%E5%BB%BAPPTP-VPN/"/>
      <url>/2021/09/02/Centos7-%E6%90%AD%E5%BB%BAPPTP-VPN/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本章节主要是通过学习大佬<a href="https://bfchengnuo.com/2017/10/27/CentOS7%E6%90%AD%E5%BB%BAPPTP%E6%9C%8D%E5%8A%A1/">Kerronex</a>、<a href="https://me.jinchuang.org/archives/517.html">靳闯</a>，为自己的阿里云服务器搭建VPN环境。(主要原因是服务器搭建了Nginx，开发的过程中发现服务器无法调用自己本地程序的接口，为此需要实现内网穿透)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Centos7 搭建VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos7 </tag>
            
            <tag> 小白 </tag>
            
            <tag> PPTP-VPN </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Butterfly部署(一)</title>
      <link href="/2021/09/01/Hexo-Butteryfly%E9%83%A8%E7%BD%B2%E3%80%901%E3%80%91/"/>
      <url>/2021/09/01/Hexo-Butteryfly%E9%83%A8%E7%BD%B2%E3%80%901%E3%80%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文章通过学习大佬<a href="https://butterfly.js.org/">Jerry</a>的Butterfly,搭建个性化个人博客。此处作为随手记录，以免未来搭建又得重新寻找教程。如果你还没有初步搭建博客，可以转到<a href="https://juejin.cn/post/6844904169355083783#heading-0">5分钟搭建Hexo个人博客</a>学习搭建。</p></blockquote><blockquote><p>【注意：可能由于本地没有安装python或则缺失vs2017等环境造成搭建失败，请自行到百度查询教程下载，此处就不单独讲解。】</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="在自己的Hexo根目录下，通过git命令克隆主题"><a href="#在自己的Hexo根目录下，通过git命令克隆主题" class="headerlink" title="在自己的Hexo根目录下，通过git命令克隆主题"></a>在自己的Hexo根目录下，通过git命令克隆主题</h3><p>这里有可能因为网络问题或则代理问题导致失败</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git clone <span class="literal">-b</span> master https://github.com/jerryc127/hexo<span class="literal">-theme</span><span class="literal">-butterfly</span>.git themes/butterfly</span><br></pre></td></tr></table></figure><h2 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h2><p>修改 Hexo 根目录下的 _config.yml，把主题改为butterfly</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>没有pug以及stylus的渲染器将无法访问，请安装：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-renderer</span><span class="literal">-pug</span> hexo<span class="literal">-renderer</span><span class="literal">-stylus</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure><h2 id="升级建议"><a href="#升级建议" class="headerlink" title="升级建议"></a>升级建议</h2><p>为了减少升级主题后带来的不便，请使用以下方式(建议，可以不做)。</p><blockquote><p>此方法只支持Hexo 5.0.0以上版本，建议使用。如果已经在 <code>source/_data/</code> 创建了 <code>butterfly.yml</code>，请记得删除掉。<br>在 hexo 的根目录创建一个文件 <code>_config.butterfly.yml</code>，并把主题目录的 <code>_config.yml</code> 内容复製到 <code>_config.butterfly.yml</code> 去。</p></blockquote><blockquote><p><strong>注意</strong>： 不要把主题目录的 <code>_config.yml</code> 删掉</p></blockquote><p>以后只需要在 <code>_config.butterfly.yml</code>进行配置就行。</p><p>Hexo会自动<strong>合并</strong>主题中的<code>_config.yml</code>和 <code>_config.butterfly.yml</code>里的配置，如果存在同名配置，会使用<code>_config.butterfly.yml</code>的配置，其优先度较高。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo-Butteryfly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 教程 </tag>
            
            <tag> Butteryfly </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
